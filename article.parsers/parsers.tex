\documentclass[11pt,twoside]{article}
\usepackage[all]{xy}
\usepackage{usu1251}

\righthyphenmin=2\relax %% перенос 2 букв разрешен
\emergencystretch=5pt\relax  %% разрешено разрежение 5pt

% Собственная команда
\newcommand{\restriction}[1]{{\rule[-2mm]{.3pt}{5mm}\rule{1mm}{0mm}}_{#1}}

\begin{document}

\markboth{{\protect\small\sf 2008 \hfill %Известия УрГУ
%\hfill \No N %TODO Номер
}} 
{\centerline{\protect\small\sf П.\,В.\,Егоров. 
ЯП с расширяемым синтаксисом}}
%Краткое название выбирается так, чтобы правый колонтитул уместился в
%одну строку.

% TODO \UDK{УДК Номер УДК!}


\title{РАСШИРЕНИЕ СИНТАКСИЧЕСКИХ АНАЛИЗАТОРОВ С СОХРАНЕНИЕМ ОБРАТНОЙ аСОВМЕСТИМОСТИ}
\author{П. В. Егоров}
\maketitle

\thispagestyle{firstpage}

\footnotetext{\hfill\\[-.3cm]
\copyright\ П.\,В.\,Егоров, 2008}

\section{Введение}
Все разработчики языков программирования (ЯП) стоят перед выбором: 
сделать язык максимально богатым, включив в него поддержку многих 
парадигм и технологий программирования, либо ограничиться небольшим 
ядром языка, поместив все остальное в различные библиотеки. Типичными
примерами первого подхода являются языки Perl и C++. 
Примерами второго подхода -- языки семейства Pascal. 
У каждого из этих подходов есть как достоинства, так и недостатки.

В данной работе рассматривается способ решения этого противоречия --–
расширяемый синтаксис языка программирования. Основная идея языка
программирования с расширяемым синтаксисом заключается в
том, чтобы с одной стороны ограничиваться небольшим подмножеством языка
везде, где этого достаточно, а в модулях, требующих интенсивной работы 
с некоторой технологией или парадигмой, подключать соответствующее расширение
синтаксиса. Таким образом, язык можно сделать максимально мощным, но при этом
позволить программисту полностью контролировать богатство языка  в каждый момент
времени. Эта идея была озвучена довольно давно.

Существуют впечатляющие примеры успешных, гибко расширяющихся программных
продуктов, например, интернет пейджер Miranda IM, или среда разработки 
Eclipse. Богатство функциональных возможностей в них сочетаются с 
гибкостью добавления новых возможностей. Разрабатывая и подключая к ядру
программы дополнительные модули можно расширять возможности программы.
Благодаря опубликованному описанию интерфейса создавать дополнительные
модули могут сторонние разработчики и вообще любые желающие. 
Аналогичные идеи можно попробовать применить и к устройству языков программирования.

Для того чтобы лучше проиллюстрировать выгоды, которые получат программисты от
такого подхода к созданию трансляторов, рассмотрим пример использования 
гипотетического языка с расширяемым синтаксисом.

\begin{Example}
Использование ЯП с расширяемым синтаксисом.
\end{Example}
\begin{verbatim}
syntax Sql;

string name = “Иван”;
SqlQuery q = sql(select count(*) from Persons where name=$name);
int count = connection.Execute(q);
\end{verbatim}

Сначала командой \verb'syntax Sql' подключается расширение синтаксиса,
добавляющее поддержку технологии sql-запросов.
Это позволяет писать sql запросы прямо в исходном коде.
Благодаря этому среда разработки может подсвечивать синтаксис sql запроса, 
а компилятор проверять его корректность непосредственно на этапе компиляции.
Основные выгоды от использования ЯП с расширяемым синтаксисом можно 
сформулировать следующим образом:
\begin{enumerate}
  \item Для решения каждого класса специфических задач можно создать расширение
  с максимально удобным синтаксисом.
  \item Многие проверки переходят с этапа выполнения на этап 
  компиляции, увеличивая скорость обнаружения ошибок. В данном примере так
  случилось с проверкой корректности sql-запроса.
\end{enumerate}

Важно подчеркнуть, что различные расширения ЯП могут создаваться группами
разработчиков, независимыми от группы, создавшей ядро языка. Этот факт может
привести к качественному увеличению скорости развития языков и парадигм
программирования. Раньше, для проверки практикой какой-то новой концепции
создавались целые новые языки. Так, например, дизайн по контракту был реализован
в специально созданном для этого языке Eiffel. Проверяемые исключения впервые
были опробованы в языке Java. Если бы можно было
вводить поддержку своих идей в свой любимый язык программирования, новые 
концепции стали изобретаться бы и отбраковываться гораздо быстрее и эффективнее.

Итак, преимущества довольно внушительные, и это подтверждается
многочисленными попытками создать язык с расширяемым синтаксисом. В качестве
примеров таких языков можно назвать, например, язык Haskel с его
метапрограммированием (\cite{Haskel}), и новые, развивающиеся языки Nemerle
(\cite{Nemerle01, Nemerle02}) и Boo с их системой макросов.
Сама же идея того, что будущее программной инженерии за гибкими, расширяемыми
языками была озвучена довольно давно. Например, ее можно увидеть в статье 
Extensible Programming for the 21st Century 
(Расширяемое программирование для 21-ого века)
\cite{Extensible}.

В данной работе будет рассмотрен несколько более более низкоуровненевый и гибкий 
по сравнению с макросами подход к решению задачи расширения синтаксиса.

Первым делом нужно определиться с термином <<расширение>>. 
Пусть есть некоторый транслируемый язык $L_0$. 
Для начала зафиксируем неформальное определение.
Язык $L_1$ можно называть расширением $L_0$, если он сохраняет все возможности 
расширяемого языка, добавляя какие-то новые возможности. Наилучшим вариантом
является сохранение обратной совместимости расширения с исходным языком.

Будем называть язык $L_1$ и его транслятор $T_1$ {\bf совместимым расширением}
языка $L_0$ и его транслятора $T_0$, если любая корректная программа на языке
$L_0$ будет корректной и в языке $L_1$, а кроме того, результат трансляции этой
программы в языке $L_1$ останется тем же, что и в языке $L_0$.

Обычно процесс трансляции разбивают на несколько последовательных этапов.
Создание ЯП с расширяемым синтаксисом означает превращение каждого такого этапа
в расширяемый. При этом контролировать сохранение обратной совместимости можно
на каждом этапе по отдельности: если обратная совместимость будет сохраняться
при расширении на каждом из этапов трансляции, то все расширение транслятора
целиком также будет обладать обратной совместимостью с исходным языком. 
Сегодня выделение в качестве двух первых этапов трансляции лексического и
синтаксического анализов стало стандартом де-факто. В этой работе будут
рассмотрены подходы к созданию расширяемой версий синтаксического
анализатора, сохраняющего совместимость при расширении.

Обозначим через $CFG$ множество всех контекстно-свободных однозначных
грамматик. Далее мы будем иметь дело только с такими грамматиками.

Ниже будут использоваться следующие общепринятые обозначения.
(\cite[стр.~27]{Aho}) Нетерминальные символы грамматики будут
обозначаться прописными латинскими буквами. Строчными латинскими буквами из конца алфавита
будут обозначатся слова над алфавитом терминальных символов.
Терминальные символы -- строчными латинскими буквами  из начала алфавита.
Слова из терминальных и нетерминальных символов -- греческими маленькими
буквами.

\section{Расширяющие преобразования грамматик}
Этап синтаксического анализа управляется грамматикой соответствующего языка.
Соответственно, расширение синтаксического анализатора может заключаться в
расширении соответствующей грамматики.

\begin{Defin}
Преобразование грамматик $\phi : CFG \to CFG$ 
называется расширяющим преобразованием грамматик, если
$$\forall G \in CFG \Rightarrow L(G) \subseteq L(\phi(G))$$.
\end{Defin}

Далее будет дано определение множества $AE$ расширяющих преобразований грамматик, 
удобных для испоьзования и исследования. 
В этой работе мы ограничимся только преобразованиями из этого класса $AE$.

\begin{Defin}
Определим множество преобразований $Add$ как множество всех преобразований
$\phi: CFG \to CFG$, добавляющих в грамматику новое правило. Другими словами
таких, что выполняются следующие условия:
$$\phi(V, \Sigma, P, S) = (V_1, \Sigma_1, P_1, S),$$
$$P \subset P_1, |P_1 \setminus P| = 1.$$
\end{Defin}

Преобразование из $Add$ может увеличить как терминальный, так и нетерминальный алфавит.
Кроме того, результат преобразования из $Add$ может оказаться неприведенной грамматикой.

%\begin{Lemma}\label{addLemma}
%Любая приведенная грамматика $G = (V, \Sigma, P, S)$ из $CFG$ может быть получена
%из пустой грамматики $G_0 = (\{S\}, \Sigma, \emptyset, S)$, последовательным
%применением преобразований из $Add$.
%\end{Lemma}

% TODO Примерное доказательство:
% На первом шаге найдем в грамматике $G$ правило, правая часть которого не
% содержит нетерминалов. Такое правило есть, в силу приведенности грамматики.
% Это правило можно добавить преобразованием из Add к пустой грамматике.
% Потом каждый раз будем искать и добавлять в растущую грамматику те правила,
% которые не содержат в правой части нетерминалов, еще отсутствующих в растущей
% грамматике. Это тоже довольно тривиально следует из приведенности грамматики
% $G$

% В целом $Add$ довольно могучее множество преобразований, что и понятно.

Некоторые авторы (\cite[П.1,~стр.~559]{Aho}, \cite[4.1,~стр.~29]{Zem}) 
при обсуждении расширения синтаксиса ограничиваются лишь этим классом 
раширяющих преобразований.
В данной же работе предлагается ввести еще один класс преобразований, 
делающий расширение грамматики более гибким.

\begin{Defin}
Определим множество преобразований $Extract$ как множество
всех преобразований 
$\phi : CFG \to CFG$ таких, что выполняются следующие условия:
\begin{enumerate}
	\item $\phi(V, \Sigma, P, S) = (V_1, \Sigma, P_1, S)$
	\item $V_1 = V \cup \{B\}, B \notin V$
  \item $P_1 = (P \setminus  \{A \rightarrow \alpha \beta \gamma\})
        \cup \{ A \rightarrow \alpha B \gamma, B \rightarrow \beta\}$,
        для некоторого правила $A \rightarrow \alpha \beta \gamma$ из $P$.
\end{enumerate}
\end{Defin}

Другими словами, после применения преобразования из $Extract$, одно
некоторое правило $A \to \alpha \beta \gamma$ заменяется двумя правилами:
$$A \to \alpha B \gamma$$
$$B \to \beta$$

Преобразования из $Extract$ расширяют нетерминальный алфавит,
но не расширяют терминальный.
Кроме того они не изменяют языка грамматики, не изменяют свойства 
однозначности и приведенности грамматики.

\begin{Defin}
$AE = Add \cup Extract$
\end{Defin}
В множестве $AE$ преобразования $Extract$ играют роль подготовки
грамматики к расширению языка, а преобразования $Add$ собственно расширяют
язык. Интуитивно понятно, что наличие преобразований $Extract$ снижает требования 
к тщательности проектирования грамматики исходного языка. 

Далее мы будем работать только с расширениями, полученными композицией
конечного количества преобразований из $AE$:
\begin{Defin}
Пусть $\Phi$ -- класс некоторых расширяющих преобразований.
Обозначим через $\Phi^\star$ множество всевозможных композиций преобразований 
из $\Phi$. 
\end{Defin}

Довольно легко заметить, что элементы $AE^\star$ --
это расширяющие преобразования.





\section{Синтаксический анализатор}

\begin{Defin}
Пусть $L$ -- некоторый язык. Тогда синтаксическим
анализатором языка $L$ будем называть произвольную функцию, определенную на $L$.
\end{Defin}

Таким образом на данном этапе мы не накладываем никаких ограничений на то, что
является результатом работы синтаксического анализатора.

\begin{Defin}
Пусть $w$ -- слово языка $L(G)$, а $s$ -- синтаксический анализатор языка $L(G)$.
Тогда $s(w)$ будем называть внутренним представлением слова $w$ в грамматике $G$.
\end{Defin}

Далее дадим более формальное определение обратной совместимости для
синтаксических анализаторов.
\begin{Defin}
Пусть $G_1, G_2 \in CFG$, причем $L(G_1) \subseteq L(G_2)$. 
Пусть $s_1, s_2$ -- синтаксические анализаторы языков 
$L(G_1)$ и $L(G_2)$. 
Тогда $s_2$ будем называть совместимым с $s_1$, если
$s_2\restriction{L(G_1)} = s_1$
\end{Defin}





\section{Выбор внутреннего представления}
В задаче трансляции синтаксический анализатор занимается не только
распознаванием корректных программ, но и построением некоторого внутреннего
представления программы в качестве результата своей работы. 
Этот раздел содержит ряд примеров, на основе которых далее будет построено 
удобное внутреннее представление и соответствующий алгоритм синтаксического анализа.

Для начала попробуем использовать в качестве внутреннего представления
классическое дерево вывода.
Для некоторого слова $w$ языка $L(G)$ обозначим через $s(w)$ дерево вывода $w$ в
$G$.

Ниже приведено два примера, поясняющих, почему дерево вывода является не
самым удачным внутренним представлением в рамках задачи расширения синтаксиса.

\begin{Example}
Простейшее нарушение совместимости из-за цепных узлов, то есть узлов ровно с
одним сыном.
\end{Example}
Рассмотрим две грамматики:
$$G_1: S \to abc$$
$$G_2: S \to aBc; B \to b$$
Очевидно, $G_2$ получается из $G_1$ применением преобразования из $Extract$. 
Однако видно, что $s_1(abc) \neq s_2(abc)$. 

\begin{graph}
	S*\frm{o}(
		-[dl]a,
		-[d]b,
		-[dr]c
	)
	[rrrrr]
	S*\frm{o}(
		-[dl]a,
		-[d]B*\frm{o}(-[d]b),
		-[dr]c
	)
\end{graph}

Таким образом расширение грамматики с помощью преобразований из $AE$ приводит к
несовместимости исходного и расширенного синтаксических анализаторов. 
Значит такой выбор устройства синтаксических анализаторов не подходит для
конструирования расширяемых трансляторов.

Вырезание цепных узлов, показанным ниже образом решает этот
класс проблем.

\begin{graph}
	-[d]A*\frm{o}(
		-[dl]{n_1\ldots n_s},
		-[d]B*\frm{o} (-[d]{n_{s+1} \ldots n_t}),
		-[dr]{n_{t+1}\ldots n_m}
	)
	[rrrrru]
	-[d]A*\frm{o}(
		-[dll]{n_1\ldots n_s},
		-[d]{n_{s+1}\ldots n_t},
		-[drr]{n_{t+1}\ldots n_m}
	)
\end{graph}

\begin{Example}
Нарушение совместимости из-за $\varepsilon$-листьев.
\end{Example}
Еще раз рассмотрим две грамматики:
$$G_1: S \to a$$
$$G_2: S \to aA; A \to \varepsilon$$
Аналогично $G_2$ получается из $G_1$ применением преобразования из $Extract$.
Cлово $a$ содержится в обоих языках. А деревья вывода этого слова в $G_1$ и $G_2$
будут различными, даже если цепные узлы, раскрытые по правилу 
$A \to \varepsilon$ будут вырезаны из дерева вывода в $G_2$.

\begin{graph}
	S*\frm{o}(
		-[d]a
	)
	[rrrrr]
	S*\frm{o}(
		-[dl]a,
		-[dr]{\varepsilon}
	)
\end{graph}

Далее описано внутреннее представление, в основе которого лежит
классическое дерево вывода, и устройство соответствующего синтаксического
анализатора, лишенное этих двух недостатков.

\section{Сокращенное дерево вывода}

Пусть есть некоторая грамматика $G = (V, \Sigma, P, S)$ и $p$ -- это некоторое
правило вывода из $P$. Через $len(p)$ будем обозначать длину правой части правила вывода $p$.

\begin{Defin}
Разметкой грамматики $G$ будем называть функцию $m$, которая каждому правилу
вывода грамматики $G$ будет ставить в соответствие кортеж, состоящий из нулей и
единиц, длиной в количество символов в правой части своего аргумента. Другми
словами для любого правила $p$ $m(p)$ есть кортеж 
$$(m_1, m_2, \ldots m_{len(p)}), \quad \mbox{где} \quad m_i \in \{0, 1\}$$ 
\end{Defin}
Кортеж $m(p)$ будем называть разметкой правила $p$.

Для удобства введем следующее обозначение для элементов кортежа:

$m(p) = (m(p, 1), m(p, 2), \ldots m(p, len(p)))$.

Значение $m(p, i)$ будем называть разметкой $i$-ого символа правой части
правила $p$.

Будем обозначать разметку правила вывода с помощью верхнего индекса у символов
правой части. Например для правила вывода 
$p: A \to BCde$  и разметки $m(p) = (0, 1, 0, 1)$, правило вывода
будем обозначать так:
$p: A \to B^0 C^1 d^0 e^1$

Разметка нам потребуется для того, чтобы вырезать некоторые
узлы из дерева вывода. 

\begin{Defin}
Определим множество размеченных грамматик $\Gamma_M$ как множество
всевозможных пар $(G, m)$, где $G \in CFG$, а $m$ -- разметка $G$.
Саму пару $(G, m)$ будем называть размеченной грамматикой.
\end{Defin}

Работая с размеченной грамматикой, каждому узлу кроме корня в классическом дереве 
вывода можно сопоставить значение разметки правила, в результате применения которого 
данный узел появился. 
Такое сопоставление будем называть разметкой узлов дерева вывода. 
Для единообразия доопределим разметку на корне дерева единицей.
Чтобы пояснить идею разметки дерева вывода, обратимся к примеру:

Пусть дана следующая грамматика:

$$T \to R^0 E^0 E^1$$
$$R \to s^1 a^0 m^0$$
$$E \to \varepsilon$$
$$E \to p^1 l^0 e^1$$

Соответствующее дерево вывода слова <<sample>> в данной грамматике будет
выглядеть так:

\begin{graph}
{T^1}*\frm{o} (
	-[dll]	{R^0}*\frm{o} (
		-[dl]	{s^1}, 
		-[d]	{a^0}, 
		-[dr]	{m^0}), 
	-[d]	{E^0}*\frm{o} (
		-[d]	\varepsilon), 
	-[drr]	{E^1}*\frm{o} (
		-[dl]	{p^1}, 
		-[d]	{l^0}, 
		-[dr]	{e^1}), 
)
\end{graph}

\begin{Defin}
Вспомогательным деревом вывода слова $w$ в грамматике $G$, назовем
дерево, полученное из обычного дерева вывода слова $w$ в грамматике $G$, 
в результате удаления всех листьев, помеченных $\varepsilon$.
\end{Defin}

\begin{Defin}
Сокращенным деревом вывода слова $w$ в грамматике $G$, с разметкой $m$ назовем
дерево, полученное из вспомогательного дерева вывода слова $w$ в грамматике $G$, 
путем вырезания из дерева всех узлов, размеченных нулями. Ниже дано определение
вырезания узла из дерева.
\end{Defin}

\begin{Defin}
Пусть у узла $p_1$ есть сыновья $n_1, n_2, \ldots n_k$. 
А у узла $n_i, (1 \le i \le k)$ есть сыновья $c_1, c_2, \ldots c_m$.
Вырезанием узла $n_i$ из дерева, называется операция замены
в списке сыновей $p_1$ узла $n_i$ на список своих сыновей 
$c_1, c_2, \ldots c_m$.
\end{Defin}

\begin{Example}
Сокращенное дерево вывода для дерева вывода из предыдущего примера.
\end{Example}

Исходное дерево вывода:

\begin{graph}
{T^1}*\frm{o} (
	-[dll]	{R^0}*\frm{o} (
		-[dl]	{s^1}, 
		-[d]	{a^0}, 
		-[dr]	{m^0}), 
	-[d]	{E^0}*\frm{o} (
		-[d]	\varepsilon), 
	-[drr]	{E^1}*\frm{o} (
		-[dl]	{p^1}, 
		-[d]	{l^0}, 
		-[dr]	{e^1}), 
)
\end{graph}

\vspace{12pt}
Вспомогательное дерево вывода:

\begin{graph}
{T^1}*\frm{o} (
	-[dll]	{R^0}*\frm{o} (
		-[dl]	{s^1}, 
		-[d]	{a^0}, 
		-[dr]	{m^0}), 
	-[d]	{E^0}*\frm{o}, 
	-[drr]	{E^1}*\frm{o} (
		-[dl]	{p^1}, 
		-[d]	{l^0}, 
		-[dr]	{e^1}), 
)
\end{graph}

\vspace{12pt}
Сокращенное дерево вывода:

\begin{graph}
{T^1}*\frm{o} (
	-[dl]	{s^1},
	-[dr]	{E^1}*\frm{o} (
		-[dl]	{p^1}, 
		-[dr]	{e^1}), 
)
\end{graph}

\vspace{12pt}

\begin{Lemma} \label{cutLemma}
Вырезание узлов при сокращении дерева можно выполнять в произвольном порядке.
\end{Lemma}
%TODO Доказать cutLemma

Для того, чтобы двигаться дальше, нужно ввести
дополнительный термин <<генератор синтаксических анализаторов>>.

\begin{Defin}
Пусть $CT$ -- это множество всех сокращенных деревьев вывода.
Определим $ct\langle G, m\rangle$ как синтаксический анализатор, который слову
ставит в соответствие его сокращенное дерево вывода в грамматике $G$ с разметкой $m$.

Будем обозначать $ct$ функцию, которая размеченной грамматике ставит в
соответствие синтаксический анализатор $ct\langle G, m \rangle$.
\end{Defin}






\section{Безопасность $AE^\star$}

Приступим к изучению свойств функции $ct$.

\begin{Defin}
Пусть $\Phi$ -- множество расширяющих преобразований грамматик.
Будем говорить, что $\Phi$ -- безопасная система преобразований, 
если для любой размеченной граматики $(G_1, m_1)$ и любого преобразования
$\phi \in \Phi$ существует такая разметка $m_2$ грамматики $G_2 = \phi(G_1)$,
что выполняются следующие условия:
\begin{enumerate}
  \item $m_1\restriction{P_1 \cap P_2} = m_2\restriction{P_1 \cap P_2}$;
  \item $ct \langle G_2, m_2 \rangle\restriction{L(G_1)} = ct \langle G_1, m_1
  \rangle$.
\end{enumerate}
\end{Defin}
Другими словами, каким бы образом безопасная система преобразований не изменила
грамматику, всегда удастся доопределить разметку на новых правилах так, чтобы
соответствующие синтаксические анализаторы оказались совместимы. Кроме того, 
первое условие нам гарантирует, что новая разметка будет отличаться от старой
только на новых правилах. Это означает, что изменение разметки будет носить
локальный характер.

Ниже будет показано, что система преобразований $AE^\star$ является
безопасной -- этот факт является одним из главных результатов данной работы.


\begin{Lemma}\label{mainLemma}
Система преобразований $AE$ является безопасной.
\end{Lemma}

\begin{proof2}
Возьмем произвольную размеченную грамматику $(G_1, m_1)$ и преобразование $\phi$
из $AE = Add \cup Extract$. 
Пусть $G_1 = (V_1, \Sigma_1, P_1, S)$. Рассмотрим два случая.

Случай 1. $\phi \in Add$. 
Для любого слова $w$ из языка $L(G_1)$ рассмотрим его дерево вывода в
грамматике $G_1$. Очевидно, это дерево также будет являться деревом вывода слова
$w$ и в грамматике $G_2 = \phi(G_1) = (V_1, \Sigma_2, P_2, S)$. 
Следовательно, вспомогательное дерево вывода слова $w$ в грамматике $G_1$ будет
также являться вспомогательным деревом вывода $w$ в $G_2$. Рассмотрим
произвольную разметку $m_2$ грамматики $G_2$ такую, что $m_2\restriction{P_1} = m_1$. 
Поскольку во вспомогательном дереве вывода присутствуют лишь узлы, полученные с помощью
правил вывода из $P_1$, на которых разметка сохранилась, то сокращенное
дерево вывода $w$ в $(G_1, m_1)$ совпадет с сокращенным деревом вывода $w$ 
в $(G_2, m_2)$, то есть $ct\langle G_1, m_1\rangle(w) = ct\langle G_2,
m_2\rangle(w)$.

Случай 2. $\phi \in Extract$. 
Для любого слова $w$ из языка $L(G_1)$ рассмотрим его вспомогательное
дерево вывода в грамматике $G_1$. 
Обозначим через $Nodes$ множество всех узлов этого дерева и введем на этом
множестве три функции:
\begin{enumerate}
 \item $Sym: Nodes \to \Sigma_1 \cup V_1$ такую, что узел $n \in Nodes$ помечен
 символом $Sym(n)$.

  \item $Sons$, которая каждому узлу $n \in Nodes$ ставит в соответствие
упорядоченный кортеж узлов, являющихся сыновьями $n$.

  \item  $Prod: \{n \in Nodes | Sym(n) \in V_1\} \to P_1$ такую, 
что $Prod(n)$ -- это правило вывода, по которому был раскрыт узел $n$.
\end{enumerate}

Пусть $\phi$ удаляет правило $q_0: A \to \alpha\beta\gamma$ 
и добавляет вместо него правила 
$q_1: A \to \alpha B \gamma$ и 
$q_2: B \to \beta$. 

Для каждого элемента $\bar{n}$ из множества 
$Nodes(q_0) = \{n \in Nodes | Prod(n) = q_0\} \neq \emptyset$
проделаем следующую операцию:

Пусть $Sons(\bar{n}) = (n_1, \ldots n_m)$. Тогда существуют такие два целых
числа $s, t$ ($0 \leq s \leq t \leq m$), что
$$Sym(n_1)\ldots Sym(n_s) = \alpha$$
$$Sym(n_{s+1})\ldots Sym(n_t) = \beta$$
$$Sym(n_{t+1})\ldots Sym(n_m) = \gamma$$
Создадим новый узел $\dot{n}$, помеченный $B$, и все узлы $n_{s+1} \ldots n_t$, 
вместе со своими поддеревьями, сохраняя порядок, сделаем сыновьями $\dot{n}$. 
А у узла $\bar{n}$ удалим их из списка сыновей, а на их место добавим 
узел $\dot{n}$. Схематично эту операцию можно представить следующим образом:

\begin{graph}
	-[d]A*\frm{o}(
		-[dll]{n_1\ldots n_s} [d] \alpha,
		-[d]{n_{s+1}\ldots n_t} [d] \beta,
		-[drr]{n_{t+1}\ldots n_m} [d] \gamma
	)
	[rrrrru]-[d]A*\frm{o}(
		-[dl]{n_1\ldots n_s},
		-[d]B*\frm{o} (-[d]{n_{s+1} \ldots n_t}),
		-[dr]{n_{t+1}\ldots n_m}
	)
\end{graph}

Несложно заметить, что после того, как все узлы, раскрытые по правилу вывода
$q_0$, будут преобразованы описанным образом, мы получим вспомогательное дерево
вывода слова $w$ в грамматике $G_2 = \phi(G_1) = (V_2, \Sigma_1, P_2, S)$.
И действительно, слово, читающееся слева направо по листьям, помеченным
терминалами, не изменилось. Узлы не из $Nodes(q_0)$ мы не изменяли и можно
считать, что они были раскрыты по правилам вывода из 
$P_1 \setminus \{q_0\} \subset P_2$.
Узлы из $Nodes(q_0)$ после изменения, можно считать раскрытыми по $q_1 \in
P_2$, а вновь созданные узлы, можно считать расрытыми по $q_2 \in P_2$.

Рассмотрим произвольную разметку $m_2$ граматики $G_2$ такую, что 
\begin{enumerate}
\item $m_2 \restriction{P_2 \setminus \{q_1, q_2\}} = m_1\restriction{P_1
\setminus \{q_0\}}$
\item $\forall i \le s \Rightarrow m_2(q_1, i) = m_1(q_0, i)$
\item $m_2(q_1, s+1) = 0$
\item $\forall i \ge 1 \Rightarrow m_2(q_1, s+1+i) = m_1(q_0, t+i)$
\item $\forall i \Rightarrow m_2(q_2, i) = m_1(q_0, s + i)$
\end{enumerate}
Рассмотрим вспомогательное дерево вывода $w$ в $G_1$ и полученное из него
вспомогательное дерево вывода $w$ в $G_2$.
При сокращении этих двух деревьев, после добавления искусственного корня, первым
делом удалим все узлы, раскрытые по $q_2$ (это сделать можно по лемме \ref{cutLemma}). 
Очевидно, после этого оба дерева станут равны, а разметки совпадут на всех 
правилах, по которым был раскрыт хотя бы один узел, оставшийся в деревях. 
Но в этом случае, дальнейшее сокращение будет проходить одинаково в обоих
деревьях. А это значит, что сокращенное дерево вывода $w$ в $(G_2, m_2)$
совпадает с сокращенным деревом вывода $w$ в $(G_1, m_1)$.
Другими словами 
$ct\langle G_1, m_1 \rangle (w) = ct\langle G_2, m_2 \rangle (w)$.
\end{proof2}

\begin{Lemma} \label{chainLemma}
Пусть $G \in CFG, \phi \in AE^\star, w \in L(G)$.
Рассмотрим вывод $w$ в $G$:
$$S \Rightarrow \alpha_1 \Rightarrow \alpha_2 \Rightarrow \cdots \Rightarrow w$$
Тогда существует следующий вывод $w$ в $\phi(G)$:
$$S \Rightarrow \alpha_{0,1} \Rightarrow \alpha_{0,2} \Rightarrow \cdots
\Rightarrow \alpha_1 \Rightarrow \alpha_{1,1} \Rightarrow \alpha_{1,2} 
\Rightarrow \cdots \Rightarrow \alpha_2 \Rightarrow \cdots \Rightarrow w$$
\end{Lemma}

%TODO Доказать chainLemma

\begin{Thm}
Система преобразований $AE^\star$ является безопасной.
\end{Thm}
\begin{proof2}
Возьмем произвольную размеченную грамматику $(G_1, m_1)$ из $\Gamma_M$ и
произвольное преобразование 
$\phi = \phi_n \circ \cdots \circ \phi_2 \circ \phi_1$ из $AE^\star$.
Введем обозначения:
$$G_1 = (V_1, \Sigma_1, P_1, S);$$
$$G_{i+1} = (V_{i+1}, \Sigma_{i+1}, P_{i+1}, S) = \phi_i (G_i), i=1..n.$$
Согласно лемме \ref{mainLemma}, существуют такие разметки 
$m_i: P_i \to \{0, 1\}, i=2..n+1$, что
$$m_2\restriction{P_1 \cap P_2} = m_1\restriction{P_1 \cap P_2}$$
$$m_3\restriction{P_2 \cap P_3} = m_2\restriction{P_2 \cap P_3}$$
$$\cdots$$
$$m_{n+1}\restriction{P_n \cap P_{n+1}} = m_n\restriction{P_n \cap P_{n+1}}$$

При этом для любого $i$ из промежутка от 1 до $n$ 
$ct\langle G_{i+1}, m_{i+1} \rangle$ совместим с 
$ct\langle G_i, m_i \rangle$.

Докажем, что $ct\langle G_{n+1}, m_{n+1} \rangle$ 
совместим с $ct\langle G_1, m_1 \rangle$.
Для этого достаточно показать, что 
$m_{n+1}\restriction{P_1 \cap P_{n+1}} = m_1\restriction{P_1 \cap P_{n+1}}$.

Заметим, что из определния $m_i$ можно заключить, что
$m_{n+1}\restriction{P_1 \cap P_2 \cap \ldots \cap P_n} 
= m_1\restriction{P_1 \cap P_2 \cap \ldots \cap P_n}$.
Докажем, что множество $P_1 \cap P_{n+1} \setminus (P_2 \cap \ldots \cap P_n)$ пусто. 
Очевидно, что этого достаточно для завершения доказательства теоремы. 

Предположим обратное. Тогда существует правило вывода
$q \in P_1 \cap P_{n+1} \setminus (P_2 \cap \ldots \cap P_n)$.
Обозначим $k = max \{i | 1 < i < n+1, q \not \in P_i \}$. 
Тогда $q \in P_{k+1} \setminus P_k$. 

Найдем любое слово $w \in L(G_1)$ такое, что в его выводе в
грамматике $G_1$ присутствует применение правила $q$, 
преобразующее $\alpha$ в $\beta$:

$$S \Rightarrow \cdots \Rightarrow \alpha \Rightarrow \beta \Rightarrow \cdots \Rightarrow w$$

По лемме \ref{chainLemma} в грамматике $G_{k}$, вывод слова $w$ будет иметь
вид:

$$S \Rightarrow \cdots \Rightarrow \alpha \Rightarrow 
\alpha_1 \Rightarrow \alpha_2 \Rightarrow \cdots \Rightarrow \alpha_r
\Rightarrow \beta \Rightarrow \cdots \Rightarrow w$$
Причем $r > 0$, так как $q \not \in P_{k}$.

По лемме \ref{chainLemma} в грамматике $G_{k+1}$, вывод слова $w$ будет иметь
вид:

$$S \Rightarrow \cdots \Rightarrow \alpha \Rightarrow 
\bar{\alpha_1} \Rightarrow \bar{\alpha_2} \Rightarrow \cdots \Rightarrow
\bar{\alpha}_{\bar{r}} \Rightarrow \beta \Rightarrow \cdots \Rightarrow w$$
Причем $\bar{r} \geq r > 0$.

Однако поскольку $q \in P_{k+1}$, то существует также другой,
отличный от данного, вывод слова $w$ в $G_{k+1}$:

$$S \Rightarrow \cdots \Rightarrow \alpha \Rightarrow \beta \Rightarrow \cdots \Rightarrow w$$

Что противоречит однозначности грамматики $G_{k+1}$.
А значит действительно 
$P_1 \cap P_{n+1} \setminus (P_2 \cap \ldots \cap P_n) = \emptyset$.
\end{proof2}

\section{Заключение}
В качестве резюме, перечислены ключевые результаты данной работы.

Была предложена простая и выразительная система преобразований грамматик $AE^\star$.

Были предложены концепции размеченной грамматики, 
синтаксического анализатора $ct$ и сокращенных деревьев вывода. Синтаксический
анализатор управляется размеченной грамматикой и выдает в качестве результата
своей работы сокращенные деревья вывода.

Показано, что при применении к размеченной грамматике преобразований из
$AE^\star$, разметку у полученной в результате грамматики можно
доопределить на новых правилах вывода так, чтобы синтаксический анализатор
после применения к его грамматике преобразования из $AE^\star$ оставался
совместимым с исходным синтаксическим анализатором.

Полученный результат позволяет определить аналогичные классы преобразований 
$Add$ и $Extract$ на множестве размеченных грамматик так, чтобы они изменяли разметку 
исходных правил вывода лишь там, где это необходимо для сохранения обратной совместимости
исходного и расширенного синтаксических анализаторов.

Локальность изменения разметки при расширении понадобится, когда встанет вопрос
об одновременном применении нескольких независимых преобразований одной и той
же грамматики. Тот факт, что каждое из преобразований меняет разметку лишь
локально, уменьшит количество конфликтов, в которых несколько преобразований
претендует на изменение одних и тех же правил вывода.

\small

\begin{thebibliography}{99}

	\bibitem{Aho}
	\textsc{Ахо А.\, Ульман Дж.} Теория синтаксического анализа, перевода и
	компиляции. Том 1. Синтаксический анализ. М.: Мир, 1978.

	\bibitem{Haskel}
	\textsc{Sheard T.\, Jones S. P.} Template meta-programming for Haskell. In
	Proceedings of the Haskell workshop, pp. 1--16. ACM Press, 2002.

	\bibitem{Nemerle01}
	\textsc{Moskal M.\, Olszta P. W.\, Skalski K.} Nemerle. Introduction to a
	Functional .NET Language, www.nemerle.org. 

	\bibitem{Nemerle02}
	\textsc{Skalski K.} Syntax-extending and type-reflecting macros in an
	object-oriented language. Master Thesis, Institute of Computer Science
	University of Wroclaw, 2005.

	\bibitem{Extensible}
	\textsc{Wilson G.\, V.} Extensible Programming for the 21st Century. ACM
	Queue, Programming languages, Vol. 2, No. 9 -- Dec/Jan 2004--2005.
	
	\bibitem{Zem}
	\textsc{Zemlicka, M.} Principles of Kind Parsing. PhD Thesis. Charles Univerity, 
	Faculty of Mathematics and Physics, Prague, Czech Republic, December 2006.

\end{thebibliography}
\end{document}
