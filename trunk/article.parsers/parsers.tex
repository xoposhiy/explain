\documentclass{article}
\usepackage[cp1251]{inputenc}
\usepackage[english,russian]{babel}
\usepackage[all]{xy}

\newtheorem{df}{Определение} 
\newtheorem{remark}{Замечание} 
\newtheorem{theorem}{Теорема} 
\newtheorem{lemma}{Лемма} 
\newtheorem{hyp}{Гипотеза} 
\newtheorem{ex}{Пример} 
\newcommand{\restriction}[1]{{\rule[-2mm]{.3pt}{5mm}\rule{1mm}{0mm}}_{#1}}


\begin{document}

\title{Языки программирования с расширяемым синтаксисом. Синтаксический анализ}
\author{Егоров~П.В.}


\section{Введение}
Все разработчики языков программирования стоят перед выбором: 
сделать язык максимально богатым, включив в него поддержку многих 
парадигм и технологий программирования, либо ограничиться небольшим 
ядром языка, поместив всё остальное в различные библиотеки. Типичными
примерами первого подхода являются языки Perl и C++. 
Примерами второго подхода --- языки семейства Pascal. 
У каждого из этих подходов есть как достоинства, так и недостатки.

В данной работе рассматривается способ решения этого противоречия --–
расширяемый синтаксис языка программирования. Основная идея языка
программирования с расширяемым синтаксисом заключается в
том, чтобы с одной стороны можно ограничиваться небольшим подмножеством языка
везде, где этого достаточно, а в модулях, требующих интенсивной работы 
с некоторой технологией или парадигмой, подключать соответствующее расширение
синтаксиса. Таким образом, язык можно сделать максимально мощным, но при этом
позволить программисту полностью контролировать богатство языка  в каждый момент
времени.

Существуют впечатляющие примеры успешных, гибко расширяющихся программных
продуктов, например, интернет пейджер Miranda IM, или среда разработки 
Eclipse. Богатство функциональных возможностей в них сочетаются с 
гибкостью добавления новых возможностей. Разрабатывая и подключая к ядру
программы дополнительные модули можно расширять возможности программы.
Причём благодаря опубликованному описанию интерфейса создавать дополнительные
модули могут сторонние разработчики и вообще любые желающие.

Для того чтобы лучше проиллюстрировать выгоды, которые получат программисты от
такого подхода к созданию трансляторов, рассмотрим пример использования 
гипотетического языка с расширяемым синтаксисом.

\begin{ex}
Использование ЯП с расширяемым синтаксисом.
\end{ex}
\begin{verbatim}
syntax Sql;

string name = “Иван”;
SqlQuery q = sql(select count(*) from Persons where name=$name);
int count = connection.Execute(q);
\end{verbatim}

Сначала командой \verb'syntax Sql' подключается расширение синтаксиса,
добавляющее поддержку технологии sql-запросов.
Это позволяет писать sql запросы прямо в исходном коде.
Благодаря этому среда разработки может подсвечивать синтаксис sql запроса, 
а компилятор проверять его корректность непосредственно на этапе компиляции.
Основные выгоды от использования ЯП с расширяемым синтаксисом можно 
сформулировать следующим образом:
\begin{enumerate}
  \item Для решения каждого класса специфических задач можно создать расширение
  с максимально удобным синтаксисом.
  \item Многие проверки переходят с этапа выполнения на этап 
  компиляции, увеличивая скорость обнаружения ошибок. В данном примере так
  случилось с проверкой корректности sql-запроса.
\end{enumerate}

Важно подчеркнуть, что различные расширения ЯП могут создаваться группами
разработчиков, независимыми от группы, создавшей ядро языка. Этот факт может
привести к качественному увеличению скорости развития языков и парадигм
программирования. Раньше, для проверки практикой какой-то новой концепции
создавались целые новые языки. Так, например, дизайн по контракту был реализован
в специально созданном для этого языке Eiffel. Проверяемые исключения впервые
были опробованы в языке Java (к слову, не очень удачно). Если бы можно было
вводить поддержку своих идей в свой любимый язык программирования, новые 
концепции стали изобретаться бы и отбраковываться гораздо быстрее и эффективнее.

Итак, преимущества довольно внушительные, поэтому можно перейти к дальнейшему
развитию идеи. В этой статье рассмотрен один из подходов к созданию
расширяемого транслятора.

\section{Расширение}
Первым делом нужно определиться с термином ``расширение''. 
Пусть есть некоторый транслируемый язык $L_0$. 
Для начала зафиксируем неформальное определение.
Язык $L_1$ можно называть расширением $L_0$, если он сохраняет все возможности 
расширяемого языка, добавляя какие-то новые возможности. Наилучшим вариантом
является сохранение обратной совместимости расширения с исходным языком.

Будем называть язык $L_1$ и его транслятор $T_1$ {\bf совместимым расширением}
языка $L_0$ и его транслятора $T_0$, если любая корректная программа на языке
$L_0$ будет корректной и в языке $L_1$, а кроме того, результат трансляции этой
программы в языке $L_1$ останется тем же, что и в языке $L_0$.

Обычно процесс трансляции разбивают на несколько последовательных этапов.
Создание ЯП с расширяемым синтаксисом означает превращение каждого такого этапа
в расширяемый. При этом контролировать сохранение обратной совместимости можно
на каждом этапе по отдельности: если обратная совместимость будет сохраняться
при расширении на каждом из этапов трансляции, то всё расширение транслятора
целиком также будет обладать обратной совместимостью с исходным языком. 
Сегодня выделение в качестве двух первых этапов трансляции лексического и
синтаксического анализов стало стандартом де-факто. В этой работе будут
рассмотрены подходы к созданию расширяемой версий синтаксического
анализатора, сохраняющего совместимость при расширении.

\section{Синтаксический анализ}

Обозначим через $CFG$ множество всех контекстно-свободных однозначных
приведенных грамматик. Далее мы будем иметь дело только с такими грамматиками.
Обозначим символом $\Gamma$ некоторое подмножество $CFG$ и зафиксируем его.
Оно будет использоваться  на протяжении всей статьи.

\begin{df}
Пусть $L$ --- это некоторый язык. Тогда синтаксическим
анализатором $G$ будем называть произвольную функцию над словами этого языка.
\end{df}

Таким образом на данном этапе мы не накладываем никаких ограничений на то, что
является результатом работы синтаксического анализатора.

\begin{df}
Пусть $G \in \Gamma, w \in L(G), s$ --- синтаксический анализатор языка $L(G)$.
Тогда $s(w)$ будем называть внутренним представлением слова $w$ в грамматике $G$.
\end{df}

Далее дадим более формальное определение обратной совместимости для
синтаксических анализаторов.
\begin{df}
Пусть $G_1, G_2 \in \Gamma: L(G_1) \subseteq L(G_2)$. 
Кроме того пусть $s_1, s_2$ --- синтаксические анализаторы языков 
$L(G_1)$ и $L(G_2)$. 
Тогда $s_2$ будем называть совместимым с $s_1$, если
$s_2\restriction{L(G_1)} = s_1$
\end{df}





\subsection{Расширяющие преобразования грамматик}
Этап синтаксического анализа управляется грамматикой соответствующего языка.
Соответственно, расширение синтаксического анализатора может заключаться в
расширении соответствующей грамматики.

\begin{df}
Преобразование грамматик $\phi : \Gamma \to \Gamma$ 
называется расширяющим преобразованием грамматик из $\Gamma$, 
если
$$\forall G \in \Gamma \Rightarrow L(G) \subseteq L(\phi(G))$$.

Перобразование $\phi : CFG \to CFG$ такое, что его сужение на $\Gamma$
является расширяющим также будем называть расширяющим.
\end{df}

Далее будет дано определение множества $AE$ удобных для исследования расширяющих
преобразований грамматик. В этой работе мы ограничимся только преобразованиями
из этого класса $AE$.

\begin{df}
Определим множество преобразований $Add$ как множество всех преобразований
$\phi: CFG \to CFG$, добавляющих в грамматику новое правило. Другими словами
таких, что выполняются следующие условия:
$$\phi(V, \Sigma, P, S) = (V, \Sigma_1, P_1, S),$$
$$\Sigma \subseteq \Sigma_1, P \subset P_1, |P_1 \setminus P| = 1.$$
\end{df}

Преобразование из $Add$ может увеличить терминальный алфавит, но не увеличивает
нетерминальный.

% Новая теоремка
\begin{remark}
Любая грамматика $G = (V, \Sigma, P, S)$ из $\Gamma$ может быть получена из
пустой грамматики $G_0 = (\{S\}, \Sigma, \emptyset, S)$, последовательным
применением преобразований из $Add$.
\end{remark}

% TODO Примерное доказательство:
% На первом шаге найдём в грамматике $G$ правило, правая часть которого не
% содержит нетерминалов. Такое правило есть, в силу приведённости грамматики.
% Это правило можно добавить преобразованием из Add к пустой грамматике.
% Потом каждый раз будем искать и добавлять в растущую грамматику те правила,
% которые не содержат в правой части нетерминалов, ещё отсутствующих в растущей
% грамматике. Это тоже довольно тривиально следует из приведённости грамматики
% $G$

% В целом $Add$ довольно могучее множество преобразований, что и понятно.

\begin{df}
Определим множество преобразований $Extract$ как множество
всех преобразований 
$\phi : CFG \to CFG$ таких, что выполняются следующие условия:
\begin{enumerate}
	\item $\phi(V, \Sigma, P, S) = (V_1, \Sigma, P_1, S)$
	\item $V_1 = V \cup \{B\}, B \notin V$
  \item $P_1 = (P \setminus  \{A \rightarrow \alpha \beta \gamma\})
        \cup \{ A \rightarrow \alpha B \gamma, B \rightarrow \beta\}$,
        для некоторого правила $A \rightarrow \alpha \beta \gamma$ из $P$.
\end{enumerate}
\end{df}

Можно считать, что после применения преобразования из $Extract$, одно некоторое
правило $A \to \alpha \beta \gamma$ заменяется двумя правилами:
$$A \to \alpha B \gamma$$
$$B \to \beta$$

Преобразования из $Extract$ расширяют нетерминальный алфавит,
но не расширяют терминальный.
Кроме того они не изменяют языка грамматики.

\begin{df}
$AE = Add \cup Extract$
\end{df}

Таким образом в множестве $AE$ преобразования $Extract$ играют роль подготовки
грамматики к расширению языка, а преобразования $Add$ собственно расширяют
язык.

Далее мы будем работать только с расширениями, полученными композицией
конечного количества преобразований из $AE$:
\begin{df}
Пусть $T$ --- класс некоторых расширяющих преобразований в $\Gamma$.
Обозначим
$$T^{\Gamma} = \{\phi \in \langle T \rangle | \phi(\Gamma) \subseteq \Gamma \}$$
\end{df}

Довольно легко заметить, что элементы $AE^{\Gamma}$ ---
это расширяющие преобразования грамматик из $\Gamma$.

Однако ограничивая себя только преобразованиями из $AE$, возможно, мы
слишком сильно ограничиваем свои возможности по расширению языка. Поэтому
вопрос о выразительной силе преобразований из $AE$ требует дополнительных 
исследований. Следующие два определения являются попыткой формализовать вопрос
о ``выразительной силе'' систем расширяющих преобразований грамматик.

\begin{df}
$T \subseteq \{\phi : CFG \to CFG\}$ называется исчерпывающей 
в $\Gamma$ системой расширяющих преобразований если выполняется условие
$$\forall G_1 \in \Gamma, \forall L_2 \in L(\Gamma) : L(G_1) \subseteq L_2
\Rightarrow \exists \phi \in T^\Gamma : L(\phi(G_1)) = L_2.$$
\end{df}

Исчерпывающая система преобразований идеальна для расширения грамматик.
С её помощью можно из любой грамматики сделать любую грамматику,
распознающую произвольное расширение языка исходной грамматики.

\begin{df}
$T \subseteq \{\phi : CFG \to CFG\}$ называется полной в $\Gamma$
системой расширяющих преобразований если выполняются условия
$$\forall L_1, L_2 \in L(\Gamma): L_1 \subseteq L_2 \Rightarrow$$
$$\exists G_1 \in \Gamma, \exists \phi \in T^\Gamma : 
L(G_1) = L_1, L(\phi(G_1)) = L_2.$$
\end{df}

Легко видеть, что второе определение более слабое: любая исчерпывающая система
преобразований является полной. Менее формально суть полноты заключается в следующем:
если знать заранее какое расширение может потребоваться, то для исходного языка
можно подобрать удачно расширяемую грамматику.

Далее будет представлена серия замечаний в которых система $AE$ исследуется на
полноту и исчерпываемость для разных классов грамматик. Но сначала сформулируем 
несколько простых лемм, которыми в дальнейшем нам придётся несколько раз
воспользоваться.

\begin{lemma} \label{chainLemma}
Пусть $G_1 \in \Gamma, \phi \in AE^\Gamma, w \in L(G_1)$.
Рассмотрим вывод $w$ в $G_1$:
$$S \Rightarrow \alpha_1 \Rightarrow \alpha_2 \Rightarrow \cdots \Rightarrow w$$
Тогда существует следующий вывод $w$ в $\phi(G_1)$:
$$S \Rightarrow \alpha_{0,1} \Rightarrow \alpha_{0,2} \Rightarrow \cdots
\Rightarrow \alpha_1 \Rightarrow \alpha_{1,1} \Rightarrow \alpha_{1,2} 
\Rightarrow \cdots \Rightarrow \alpha_2 \Rightarrow \cdots \Rightarrow w$$
\end{lemma}

%TODO Доказать chainLemma


\begin{remark} \label{LL1AERemark} 
$AE$ не является исчерпывающей в классе $LL(1)$ грамматик.
\end{remark}
Рассмотрим грамматику 
$G_1 = (V, \Sigma, P, S), \Sigma = \{a, b, c\}, V = \{S, A, B\}$: 
$$S \to AB; A \to ab; B \to ac$$
Ей соответсвует язык $L_1 = \{abac\}$. Рассмотрим язык $L_2 = \{abac, acab\}$,
для которого, очевидно, существует $LL(1)$-граматика.
Ниже докажем, что  никаким преобразованием из $AE^{LL(1)}$
невозможно привести $G_1$ к произвольной такой $LL(1)$-грамматике $G_2$, 
что $L(G_2) = L_2$. Доказательство будем вести от противного.

Допустим существует такое преобразование $\phi \in AE^{LL(1)}$, что 
$\phi(G_1) = G_2$. Рассмотрим вывод слова $abac$ в $G_1$:
$$S \Rightarrow AB \Rightarrow abB \Rightarrow abac$$
Согласно лемме \ref{chainLemma}, вывод слова $abac$ в $G_2$ может быть такой:
$$S \Rightarrow \cdots \Rightarrow AB \Rightarrow \cdots \Rightarrow abB
\Rightarrow \cdots \Rightarrow abac$$
Значит в $G_2$ $B \Rightarrow^* ac$

Кроме этого, поскольку $acab$ так же как и $abac$ начинается с буквы $a$ и в
силу принадлежности $G_2$ к классу $LL(1)$-грамматик, вывод слова $acab$ в $G_2$
может иметь вид:
$$S \Rightarrow \cdots \Rightarrow A\beta \Rightarrow \cdots 
\Rightarrow w \beta \Rightarrow \cdots \Rightarrow acab$$
Тут $w$ состоит только из терминалов. 
Рассмотрим все возможные значения $w$: $\epsilon, a, ac, aca, aca, acab$.
Учитывая то, что из $B$ выводится $ac$, из слова $AB$  может быть
выведено одно из следующих слов: $ac, aac, acac, acaac, acabac$. 
Кроме того $AB$ само выводится из аксиомы.
Получаем что одно из перечисленных выше слов содержится в $L_2 = L(G_2)$, 
что противоречит условию. Значит исходная посылка неверна и действительно не
существует преобразования из $AE$ переводящего $G_1$ в $G_2$. 
Замечение доказано.

Обозначим через $FL$ множество всех грамматик из $\Gamma$, порождающих конечные
непустые языки.
\begin{remark}
Cистема преобразований $AE$ является исчерпывающей в $FL$.
\end{remark}
Пусть $L_2 \setminus L_1 = \{w_1, \ldots, w_n\}$.
Добавим с помощью преобразований из $Add$ в грамматику $G_1$ $n$ правил вида 
$S \to w_i$.

\begin{remark}
$AE$ является полной, но не исчерпывающей в $LL(1) \cap FL$.
\end{remark}
{\bf Доказательство}

То, что $AE$ не является исчерпывающей, следует из примера, построенного при
доказательстве замечания \ref{LL1AERemark}.

Обозначим через $R$ множество $LL(1)$-грамматик, в которых все правила имеют вид
$A \to a_1 \ldots a_k$ или $A \to a_1 \ldots a_k T$, 
где $T \in V$, а $a_1, \ldots a_l \in \Sigma$.

Для любого слова $w$ из терминальных символов, грамматика с одним правилом
вывода вида $S \to w$ принадлежит множеству $R$.

Несложно построить алгоритм расширения произвольной грамматики $G_1 \in R$
до грамматики $G_2 \in R$ так, что $L(G_2)$ содержит на одно наперёд заданное
слово $w$ больше, чем $L(G_1)$.

Таким алгоритмом можно построить грамматику $L_1$ из $R$, 
а потом дополнить её до грамматики $L_2$.



Стоит заметить, что класс языков, описываемых грамматиками класса
$LL(1) \cap FL$ в точности совпадает с классом всех конечных языков. И
действительно, для любого конечного языка несложно построить $LL(1)$-грамматику.
Однако полнота и исчерпываемость - это свойства системы преобразований в классе
грамматик, а не в классе языков. Поэтому ничего странного в том, что $AE$ в
классе $FL$ является исчерпывающей, а в классе $LL(1) \cap FL$ нет, несмотря на
то, что классы языков этих классов грамматик совпадают.

Обозначим через $RL$ --- множество праволинейных грамматик из $\Gamma$, в
которых начальный символ не встречается в правых частях правил вывода.

Очевидно, любую праволинейных грамматику можно легко преобразовать так, 
чтобы она стала принадлежать $RL$.

\begin{remark}
$AE$  является исчерпывающей в классе $RL$-грамматик.
\end{remark}
{\bf Доказательство}

Для любой грамматики $G_1$ из класса $RL$, и любого языка $L_2$, таких что
$L(G_1) \subseteq L_2$ язык $L_3 = L_2 \setminus L(G_1)$ является регулярным.
По грамматике $G_1$ построим соответствующий НДКА $A_1$.
Найдём любую грамматику $G_3$ из класса $RL$ для языка $L_3$ и построим по ней 
соответствующий НДКА $A_3$.

Объединим начальные вершины $A_1$ и $A_3$. Легко показать, что мы получим
автомат, распознающий язык $L(G_2)$. По этому автомату легко построить 
соответствующую регулярную грамматику. 

Легко показать, что для любого принимаемого автоматом слова, существует
единственный путь от начального состояния до одного из конечных. Это означает,
что соответствующая грамматика будет однозначной. Можно показать, что в автомате
не будет недостижимых и тупиковых вершин, а значит грамматика будет приведённой.
Можно также показать, что степень захода начального состояния --- 0. Всё это
означает, что грамматика будет действительно из $RL$.

Осталось показать, что автомат $A_1$ с помощью последовательности преобразований
из $AE$ можно достроить до $A_3$. Но это легко сделать с помощью серии 
преобразований из $Add$.

\begin{hyp}
Система преобразований $AE$ является полной в $LL(1)$.
\end{hyp}
Эту гипотезу автору не удалось ни доказать ни опровергнуть. Однако если она
верна, то это означает, что система преобразований $AE$ может использоваться
для расширения грамматик довольно сложных языков.




\subsection{Внутреннее представление}
В задаче трансляции синтаксический анализатор занимается не только
распознаванием корректных программ, но и построением некоторого внутреннего
представления программы в качестве результата своей работы. 
Этот раздел будет посвещен поиску удобного внутреннего представления и
алгоритма синтаксического анализа, построенного на основе классического 
$LL(1)$-анализатора.

Для начала попробуем использовать в качестве внутреннего представления
классическое дерево вывода.
Для некоторого слова $w$ языка $L(G)$ обозначим через $s(w)$ дерево вывода $w$ в
$G$.

Ниже приведено два примера, поясняющих, почему дерево вывода является не
самым удачным внутренним представлением в рамках задачи расширения синтаксиса.

\begin{ex}
Простейшее нарушение совместимости из-за цепных узлов, то есть узлов ровно с
одним сыном.
\end{ex}
Рассмотрим две грамматики:
$$G_1: S \to abc$$
$$G_2: S \to aBd; B \to b$$
Очевидно, $G_2$ получается из $G_1$ применением преобразования из $Extract$. 
Однако видно, что $s_1(abc) \neq s_2(abc)$. 

\begin{graph}
	S*\frm{o}(
		-[dl]a,
		-[d]b,
		-[dr]c
	)
	[rrrrr]
	S*\frm{o}(
		-[dl]a,
		-[d]B*\frm{o}(-[d]b),
		-[dr]c
	)
\end{graph}

Таким образом расширение грамматики с помощью преобразований из $AE$ приводит к
несовместимости исходного и расширенного синтаксических анализаторов. 
Значит такой выбор устройства синтаксических анализаторов не подходит для
конструирования расширяемых трансляторов.

Вырезание цепных узлов, показанным ниже образом решает этот
класс проблем.

\begin{graph}
	-[d]A*\frm{o}(
		-[dl]{n_1\ldots n_s},
		-[d]B*\frm{o} (-[d]{n_{s+1} \ldots n_t}),
		-[dr]{n_{t+1}\ldots n_m}
	)
	[rrrrru]
	-[d]A*\frm{o}(
		-[dll]{n_1\ldots n_s},
		-[d]{n_{s+1}\ldots n_t},
		-[drr]{n_{t+1}\ldots n_m}
	)
\end{graph}

\begin{ex}
Нарушение совместимости из-за $\varepsilon$-листьев.
\end{ex}
Ещё раз рассмотрим две грамматики:
$$G_1: S \to a$$
$$G_2: S \to aA; A \to \varepsilon$$
Аналогично $G_2$ получается из $G_1$ применением преобразования из $Extract$.
Cлово $a$ содержится в обоих языках. А деревья вывода этого слова в $G_1$ и $G_2$
будут различными, даже если цепные узлы, раскрытые по правилу 
$A \to \varepsilon$ будут вырезаны из дерева вывода в $G_2$.

\begin{graph}
	S*\frm{o}(
		-[d]a
	)
	[rrrrr]
	S*\frm{o}(
		-[dl]a,
		-[dr]{\varepsilon}
	)
\end{graph}

Далее описано внутреннее представление, в основе которого лежит
классическое дерево вывода, и устройство соответствующего синтаксического
анализатора, лишённое этих двух недостатков.

\subsection{Размеченная грамматика}

Пусть есть некоторая грамматика $G = (V, \Sigma, P, S)$ и $p$ --- это некоторое
правило вывода из $P$. Введём несколько вспомогательных обозначений.

Через $p.L$ будем обозначать длину правой части правила вывода $p$.

Через $p(i)$, при $1\leq i \leq p.L$, будем обозначать $i$-ый символ правой
части правила вывода $p$.

Через $p(0)$ будем обозначать символ левой части правила вывода $p$.

\begin{df}
Разметкой грамматики $G$ будем называть функцию $m$, которая каждому правилу
вывода грамматики $G$ будет ставить в соответствие кортеж, состоящий из нулей и
единиц, длиной в количество символов в правой части своего аргумента. То есть
формально:
$$\forall p \in P, m(p) = (m_1, m_2, \ldots m_{p.L}), где m_i \in \{0, 1\}$$
\end{df}
$m(p)$ будем называть разметкой правила $p$. 

Для удобства введём слудеющее обозначение для элементов кортежа: 

$m(p) = (m(p, 1), m(p, 2), \ldots m(p, p.L))$.

Смысл разметки в том, что $i$-тому символу правой части правила вывода $p$
сопоставляется число $m(p, i)$ --- 0 либо 1. Соответсвтенно, $m(p, i)$ будем 
называть разметкой $i$-ого символа правой части правила $p$.

\begin{df}
Определим множество размеченных грамматик $\Gamma_M$ как множество
всевозможных пар $(G, m)$, где $G \in \Gamma$, а $m$ --- разметка $G$.
А саму пару $(G, m)$ будем называть размеченной грамматикой.
\end{df}

Разметку правила вывода будем обозначать с помощью верхнего индекса у символов
правой части правила вывода. Например для правила вывода 
$p: A \to BCde$  и разметки $m(p) = (0, 1, 0, 1)$, правило вывода
будем обозначать так:
$p: A \to B^0 C^1 d^0 e^1$

Разметка нам потребуется для того, чтобы вырезать некоторые
узлы из дерева вывода. 

Каждому узлу кроме корня в классическом дереве вывода можно сопоставить значение 
разметки правила, в результате применения которого появился данный узел. 
Такое сопоставление будем называть разметкой узлов дерева вывода. 
Для единообразия доопределим разметку на корне дерева единицей.
Чтобы пояснить идею разметки дерева вывода, обратимся к примеру:

Пусть дана следующая грамматика:

$$T \to R^0 E^0 E^1$$
$$R \to s^1 a^0 m^0$$
$$E \to \varepsilon$$
$$E \to p^1 l^0 e^1$$

Соответствующее дерево вывода слова ``sample'' в данной грамматике будет выглядеть
так:

\begin{graph}
{T^1}*\frm{o} (
	-[dll]	{R^0}*\frm{o} (
		-[dl]	{s^1}, 
		-[d]	{a^0}, 
		-[dr]	{m^0}), 
	-[d]	{E^0}*\frm{o} (
		-[d]	\varepsilon), 
	-[drr]	{E^1}*\frm{o} (
		-[dl]	{p^1}, 
		-[d]	{l^0}, 
		-[dr]	{e^1}), 
)
\end{graph}

\begin{df}
Вспомогательным деревом вывода слова $w$ в грамматике $G$, назовём
дерево, полученное из обычного дерева вывода слова $w$ в грамматике $G$, 
в результате удаления всех листьев, помеченных $\varepsilon$.
\end{df}

\begin{df}
Сокращённым деревом вывода слова $w$ в грамматике $G$, с разметкой $m$ назовём
дерево, полученное из вспомогательного дерева вывода слова $w$ в грамматике $G$, 
путём вырезания из дерева всех узлов, размеченных нулями.
\end{df}

\begin{ex}
Сокращённое дерево вывода для дерева вывода из предыдущего примера.
\end{ex}

Исходное дерево вывода:

\begin{graph}
{T^1}*\frm{o} (
	-[dll]	{R^0}*\frm{o} (
		-[dl]	{s^1}, 
		-[d]	{a^0}, 
		-[dr]	{m^0}), 
	-[d]	{E^0}*\frm{o} (
		-[d]	\varepsilon), 
	-[drr]	{E^1}*\frm{o} (
		-[dl]	{p^1}, 
		-[d]	{l^0}, 
		-[dr]	{e^1}), 
)
\end{graph}

\vspace{12pt}
Вспомогательное дерево вывода:

\begin{graph}
{T^1}*\frm{o} (
	-[dll]	{R^0}*\frm{o} (
		-[dl]	{s^1}, 
		-[d]	{a^0}, 
		-[dr]	{m^0}), 
	-[d]	{E^0}*\frm{o}, 
	-[drr]	{E^1}*\frm{o} (
		-[dl]	{p^1}, 
		-[d]	{l^0}, 
		-[dr]	{e^1}), 
)
\end{graph}

\vspace{12pt}
Сокращённое дерево вывода:

\begin{graph}
{T^1}*\frm{o} (
	-[dl]	{s^1},
	-[dr]	{E^1}*\frm{o} (
		-[dl]	{p^1}, 
		-[dr]	{e^1}), 
)
\end{graph}

\vspace{12pt}

\begin{lemma} \label{cutLemma}
Вырезание узлов при сокращении дерева можно выполнять в произвольном порядке.
\end{lemma}
%TODO Доказать cutLemma

Чтобы двигаться дальше, придётся ввести
дополнительный термин ``генератор синтаксических анализаторов''.

\begin{df}
Пусть $CT$ --- это множество всех сокращённых деревьев вывода.
Определим $ct\langle G, m\rangle$ как синтаксический анализатор, который слову
ставит в соответствие его сокращённое дерево вывода в грамматике $G$ с разметкой $m$.

Будем обозначать $ct$ функцию, которая размеченной грамматике ставит в
соответствие синтаксический анализатор $ct\langle G, m \rangle$.
\end{df}

Приступим к изучению свойств $ct$.

\begin{df}
Пусть $\Phi$ --- множество расширяющих преобразований грамматик из $\Gamma$.
Будем говорить, что $\Phi$ --- безопасная для $ct$ система преобразований 
если
\begin{enumerate}
  \item $\forall (G_1, m_1) \in \Gamma_M, \forall \phi \in \Phi, G_2 = \phi(G_1)$
$\exists m_2$ --- разметка грамматики $G_2$; 
  \item $m_1\restriction{P_1 \cap P_2} = m_2\restriction{P_1 \cap P_2}$;
  \item $ct \langle G_2, m_2 \rangle\restriction{L(G_1)} = ct \langle G_1, m_1
  \rangle$.
\end{enumerate}
\end{df}
Другими словами, каким бы образом безопасная система преобразований не изменила
грамматику, всегда удастся доопределить разметку на новых правилах так, чтобы
соответствующие синтаксические анализаторы оказались совместимы. Кроме того, 
первое условие нам гарантирует, что новая разметка будет отличаться от старой
только на новых правилах. То есть изменение разметки будет носить локальный характер.

Ниже будет показано, что система преобразований $AE^{\Gamma}$ является
безопасной системой для $ct$.


\begin{lemma}\label{mainLemma}
Система преобразований $AE$ является безопасной для $ct$.
\end{lemma}

{\bf Доказательство.}
Возьмём произвольную размеченную грамматику $(G_1, m_1)$ из $\Gamma_M$ и $\phi$
из $AE = Add \cup Extract$. 
Пусть $G_1 = (V_1, \Sigma_1, P_1, S)$. Рассмотрим два случая.

Случай 1. $\phi \in Add$. 
Для любого слова $w$ из языка $L(G_1)$ рассмотрим его дерево вывода в
грамматике $G_1$. Очевидно, это дерево также будет являться деревом вывода слова
$w$ и в грамматике $G_2 = \phi(G_1) = (V_1, \Sigma_2, P_2, S)$. 
Следовательно, вспомогательное дерево вывода слова $w$ в грамматике $G_1$ будет
также являться вспомогательным деревом вывода $w$ в $G_2$. Рассмотрим
произвольную разметку $m_2$ грамматики $G_2$ такую, что $m_2\restriction{P_1} = m_1$. 
Поскольку во вспомогательном дереве вывода присутствуют лишь узлы, помеченные
правилами вывода из $P_1$, на которых разметка сохранилась, то сокращённое
дерево вывода $w$ в $(G_1, m_1)$ совпадёт с сокращённым деревом вывода $w$ 
в $(G_2, m_2)$, то есть $ct\langle G_1, m_1\rangle(w) = ct\langle G_2,
m_2\rangle(w)$.

Случай 2. $\phi \in Extract$. 
Для любого слова $w$ из языка $L(G_1)$ рассмотрим его вспомогательное
дерево вывода слова $w$ в грамматике $G_1$. 
Обозначим через $Nodes$ множество всех узлов этого дерева и введём на этом
множестве три функции:
\begin{enumerate}
 \item $Sym: Nodes \to \Sigma_1 \cup V_1$ такую, что узел $n \in Nodes$ помечен
 символом $Sym(n)$.

  \item $Sons$, которая каждому узлу $n \in Nodes$ ставит в соответствие
упорядоченный кортеж узлов, являющихся сыновьями $n$.

  \item  $Prod: \{n \in Nodes | Sym(n) \in V_1\} \to P_1$ такую, 
что $Prod(n)$ --- это правило вывода, по которому был раскрыт узел $n$.
\end{enumerate}

Пусть $\phi$ удаляет правило $q_0: A \to \alpha\beta\gamma$ 
и добавляет вместо него правила 
$q_1: A \to \alpha B \gamma$ и 
$q_2: B \to \beta$. 

Для каждого элемента $\bar{n}$ из множества 
$Nodes(q_0) = \{n \in Nodes | Prod(n) = q_0\} \neq \emptyset$
проделаем следующую операцию:

Пусть $Sons(\bar{n}) = (n_1, \ldots n_m)$. Тогда существуют такие два целых
числа $s, t$ ($0 \leq s \leq t \leq m$), что
$$Sym(n_1)\ldots Sym(n_s) = \alpha$$
$$Sym(n_{s+1})\ldots Sym(n_t) = \beta$$
$$Sym(n_{t+1})\ldots Sym(n_m) = \gamma$$
Создадим новый узел $\dot{n}$, помеченный $Y$, и все узлы $n_{s+1} \ldots n_t$, 
вместе со своими поддеревьями, сохраняя порядок, сделаем сыновьями $\dot{n}$. 
А у узла $\bar{n}$ удалим их из списка сыновей, а на их место добавим 
узел $\dot{n}$. Схематично эту операцию можно представить следующим образом:

\begin{graph}
	-[d]A*\frm{o}(
		-[dll]{n_1\ldots n_s} [d] \alpha,
		-[d]{n_{s+1}\ldots n_t} [d] \beta,
		-[drr]{n_{t+1}\ldots n_m} [d] \gamma
	)
	[rrrrru]-[d]A*\frm{o}(
		-[dl]{n_1\ldots n_s},
		-[d]B*\frm{o} (-[d]{n_{s+1} \ldots n_t}),
		-[dr]{n_{t+1}\ldots n_m}
	)
\end{graph}

Несложно заметить, что после того, как все узлы, раскрытые по правилу вывода
$q_0$, будут преобразованы описанным образом, мы получим вспомогательное дерево
вывода слова $w$ в грамматике $G_2 = \phi(G_1) = (V_2, \Sigma_1, P_2, S)$.
И действительно, слово, читающееся слева направо по листьям, помеченным
терминалами, не изменилось. Узлы не из $Nodes(q_0)$ мы не изменяли и можно
считать, что они были раскрыты по правилам вывода из 
$P_1 \setminus \{q_0\} \subset P_2$.
Узлы из $Nodes(q_0)$ после изменения, можно считать раскрытыми по $q_1 \in
P_2$, а вновь созданные узлы, можно считать расрытыми по $q_2 \in P_2$.

Рассмотрим произвольную разметку $m_2$ граматики $G_2$ такую, что 
\begin{enumerate}
\item $m_2 \restriction{P_2 \setminus \{q_1, q_2\}} = m_1\restriction{P_1
\setminus \{q_0\}}$
\item $\forall i \le s \Rightarrow m_2(q_1, i) = m_1(q_0, i)$
\item $m_2(q_1, s+1) = 0$
\item $\forall i \ge 1 \Rightarrow m_2(q_1, s+1+i) = m_1(q_0, t+i)$
\item $m_2(q_2, i) = m_1(q_0, s + i)$
\end{enumerate}
Рассмотрим вспомогательное дерево вывода $w$ в $G_1$ и полученное из него
вспомогательное дерево вывода $w$ в $G_2$.
При сокращении этих двух деревьев, после добавления искусственного корня, первым
делом удалим все узлы, раскрытые по $q_2$ (это сделать можно по лемме \ref{cutLemma}). 
Очевидно, после этого оба дерева станут равны, а разметки совпадут на всех 
правилах, по которым был раскрыт хотя бы один узел, оставшийся в деревях. 
Но в этом случае, дальнейшее сокращение будет проходить одинаково в обоих
деревьях. А это значит, что сокращённое дерево вывода $w$ в $(G_2, m_2)$
совпадает с сокращённым деревом вывода $w$ в $(G_1, m_1)$.
То есть $ct\langle G_1, m_1 \rangle (w) = ct\langle G_2, m_2 \rangle (w)$.

\begin{theorem}
Система преобразований $AE^\Gamma$ является безопасной для $ct$.
\end{theorem}
{\bf Доказательство.}
Возьмём произвольную размеченную грамматику $(G_1, m_1)$ из $\Gamma_M$ и
произвольное преобразование 
$\phi = \phi_n \circ \cdots \circ \phi_2 \circ \phi_1$ из $AE^\Gamma$.
Введём обозначения:
$$G_1 = (V_1, \Sigma_1, P_1, S);$$
$$G_{i+1} = (V_{i+1}, \Sigma_{i+1}, P_{i+1}, S) = \phi_i (G_i), i=1..n.$$
Согласно лемме \ref{mainLemma}, существуют такие разметки 
$m_i: P_i \to \{0, 1\}, i=2..n+1$, что
$$m_2\restriction{P_1 \cap P_2} = m_1$$
$$m_3\restriction{P_2 \cap P_3} = m_2$$
$$\cdots$$
$$m_{n+1}\restriction{P_n \cap P_{n+1}} = m_n$$

При этом для любого $i$ из промежутка от 1 до $n$ 
$ct\langle G_{i+1}, m_{i+1} \rangle$ совместим с 
$ct\langle G_i, m_i \rangle$.

Докажем, что $ct\langle G_{n+1}, m_{n+1} \rangle$ 
совместим с $ct\langle G_1, m_1 \rangle$.
Для этого достаточно показать, что $m_{n+1}\restriction{P_1 \cap P_{n+1}} = m_1$.

Заметим, что из определния $m_i$ можно заключить, что
$m_{n+1}\restriction{P_1 \cap P_2 \cap \ldots \cap P_n} = m_1$. 
Рассмотрим множество $P_1 \cap P_{n+1} \setminus (P_2 \cap \ldots \cap P_n)$.
Докажем, что это множество пусто. Очевидно, что этого достаточно для завершения 
доказательства теоремы. 

Предположим обратное. Тогда существует правило вывода
$q \in P_1 \cap P_{n+1} \setminus (P_2 \cap \ldots \cap P_n)$.
Обозначим $k = max \{i | 1 < i < n+1, q \not \in P_i \}$. 
Тогда $q \in P_{k+1} \setminus P_k$. 

Найдём любое слово $w \in L(G_1)$ такое, что в его выводе в
грамматике $G_1$ присутствует применение правила $q$, 
преобразующее $\alpha$ в $\beta$:

$$S \Rightarrow \cdots \Rightarrow \alpha \Rightarrow \beta \Rightarrow \cdots \Rightarrow w$$

По лемме \ref{chainLemma} в грамматике $G_{k}$, вывод слова $w$ будет иметь
вид:

$$S \Rightarrow \cdots \Rightarrow \alpha \Rightarrow 
\alpha_1 \Rightarrow \alpha_2 \Rightarrow \cdots \Rightarrow \alpha_r
\Rightarrow \beta \Rightarrow \cdots \Rightarrow w$$
Причём $r > 0$, так как $q \not \in P_{k}$.

По лемме \ref{chainLemma} в грамматике $G_{k+1}$, вывод слова $w$ будет иметь
вид:

$$S \Rightarrow \cdots \Rightarrow \alpha \Rightarrow 
\bar{\alpha_1} \Rightarrow \bar{\alpha_2} \Rightarrow \cdots \Rightarrow
\bar{\alpha}_{\bar{r}} \Rightarrow \beta \Rightarrow \cdots \Rightarrow w$$
Причём $\bar{r} \geq r > 0$.

Однако поскольку $q \in P_{k+1}$, то существует также другой,
отличный от данного, вывод слова $w$ в $G_{k+1}$:

$$S \Rightarrow \cdots \Rightarrow \alpha \Rightarrow \beta \Rightarrow \cdots \Rightarrow w$$

Что противоречит однозначности грамматики $G_{k+1}$.
А значит действительно 
$P_1 \cap P_{n+1} \setminus (P_2 \cap \ldots \cap P_n) = \emptyset$.

\end{document}
