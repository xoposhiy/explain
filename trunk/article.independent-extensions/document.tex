\documentclass[11pt,twoside]{article}
\usepackage[all]{xy}
\usepackage{usu1251}

\righthyphenmin=2\relax %% перенос 2 букв разрешен
\emergencystretch=5pt\relax  %% разрешено разрежение 5pt

% Собственная команда
\newcommand{\restriction}[1]{{\rule[-2mm]{.3pt}{5mm}\rule{1mm}{0mm}}_{#1}}
\newcommand{\eq}[1]{\stackrel{(\ref{#1})}{=}}

\begin{document}

\markboth{{\protect\small\sf 2008 \hfill %Известия УрГУ
%\hfill \No N %TODO Номер
}} 
{\centerline{\protect\small\sf П.\,В.\,Егоров. 
Независимые преобразования грамматик}}
%Краткое название выбирается так, чтобы правый колонтитул уместился в
%одну строку.

% TODO \UDK{УДК Номер УДК!}


\title{ОБ ОДНОВРЕМЕННОМ ПРИМЕНЕНИИ НЕСКОЛЬКИХ НЕЗАВИСИМЫХ ПРЕОБРАЗОВАНИЙ ГРАМАТИК}
\author{П. В. Егоров}
\maketitle

\thispagestyle{firstpage}

\footnotetext{\hfill\\[-.3cm]
\copyright\ П.\,В.\,Егоров, 2008}

\section{Введение}
В данной работе представлен очередной шаг к созданию расширяемых
синтаксических анализаторов формальных языков -- рассмотрены некоторые важные
вопросы, касающиеся одновременного применения нескольких независимых преобразований к грамматике.

Ниже будет описана постановка задачи и сформулированы рассматриваемые в данной работе вопросы. Далее будут
последовательно введены понятия, на основе которых затем будут даны ответы на поставленные вопросы.

\section{Постановка задачи}
Пусть у нас есть грамматика $G$ и два преобразования этой конкретной грамматики -- $\phi$ и $\psi$. Каждое
преобразование оперирует правилами вывода -- удаляет одни и добавляет другие. Если применить к грамматике одно из
преобразований, то встаёт вопрос о том как к полученной грамматике $\phi(G) \neq G$, применять $\psi$,
предназначенное для применения к $G$. В некоторых случаях это будет не возможно. В некоторых других случаях
можно немного изменив $\psi$ получить новое преобразование $\psi`$, которое уже предназначено для
применения к $\phi(G)$ и в некотором смысле преобразует $\phi(G)$ тем же способом, что и $\psi$ преобразует
$G$.

Это можно изобразить графически следующим образом:

\begin{graph}
{G} (
	-[dl]	{\phi(G)}
		-[d]	{\psi' \phi(G)},
	)
	(
	-[dr]	{\psi(G)} 
		-[d]	{\phi' \psi(G)},
)
\end{graph}

В это работе рассмотрены следующие вопросы.
Как нужно изменять исходное преобразование, чтобы его можно было применить после другого преобразования?
Какие требования логично предъявлять к этому способу модификации исходного преобразования?
Будет ли зависеть результат применения обоих преобразований от порядка их применения?

\section{Размеченная грамматика}
Пусть есть некоторая грамматика $G = (V, \Sigma, P, S)$ и $p$ -- это некоторое
правило вывода из $P$. Введём несколько вспомогательных обозначений.

Через $len(p)$ будем обозначать длину правой части правила вывода $p$.

Через $p(i)$, при $1\leq i \leq len(p)$, будем обозначать $i$-ый символ правой
части правила вывода $p$.

Через $p(0)$ будем обозначать символ левой части правила вывода $p$.

\begin{Defin}
	Разметкой грамматики $G$ будем называть функцию $m$, которая каждому правилу
	вывода грамматики $G$ будет ставить в соответствие кортеж, состоящий из нулей и
	единиц, длиной в количество символов в правой части своего аргумента. Другми
	словами для любого правила $p$ $m(p)$ есть кортеж 
	$$(m_1, m_2, \ldots m_{len(p)}), \quad \mbox{где} \quad m_i \in \{0, 1\}$$ 
\end{Defin}
%Используется?
Кортеж $m(p)$ будем называть разметкой правила $p$.

%Используется?
Для удобства введём слудеющее обозначение для элементов кортежа:

$m(p) = (m(p, 1), m(p, 2), \ldots m(p, len(p)))$.

Значение $m(p, i)$ будем называть разметкой $i$-ого символа правой части
правила $p$.


\begin{Defin}
	Определим множество размеченных грамматик $\Gamma_M$ как множество
	всевозможных пар $(G, m)$, где $G \in \Gamma$, а $m$ -- разметка $G$.
	Саму пару $(G, m)$ будем называть размеченной грамматикой.
\end{Defin}


Разметку правила вывода будем обозначать с помощью верхнего индекса у символов
правой части правила вывода. Например для правила вывода 
$p: A \to BCde$  и разметки $m(p) = (0, 1, 0, 1)$, размеченное правило вывода
будем обозначать так:
$p: A \to B^0 C^1 d^0 e^1$

\section{Синтаксический анализатор}

\begin{Defin}
	Пусть $L$ -- некоторый язык. Тогда синтаксическим
	анализатором $G$ будем называть произвольную функцию, определенную на $L$.
\end{Defin}

Ниже будет определён синтаксический анализатор $ct\langle G, m\rangle$,
управляемый размеченной грамматикой. Он будет в качестве результата возвращать
конструкцию, очень похожую на классическое дерево вывода слова в грамматике $G$.
Разметка будет им использоваться для того, чтобы вырезать некоторые
узлы из классического дерева вывода. Рассмотрим всё по порядку. 

Каждому узлу кроме корня в классическом дереве вывода можно сопоставить значение 
разметки правила, в результате применения которого появился данный узел. 
Такое сопоставление будем называть разметкой узлов дерева вывода. 
Для единообразия доопределим разметку на корне дерева единицей.
Чтобы пояснить идею разметки дерева вывода, обратимся к примеру:

Пусть дана следующая грамматика:

$$T \to R^0 E^0 E^1$$
$$R \to s^1 a^0 m^0$$
$$E \to \varepsilon$$
$$E \to p^1 l^0 e^1$$

Соответствующее дерево вывода слова <<sample>> в данной грамматике будет
выглядеть так:

\begin{graph}
{T^1}*\frm{o} (
	-[dll]	{R^0}*\frm{o} (
		-[dl]	{s^1}, 
		-[d]	{a^0}, 
		-[dr]	{m^0}), 
	-[d]	{E^0}*\frm{o} (
		-[d]	\varepsilon), 
	-[drr]	{E^1}*\frm{o} (
		-[dl]	{p^1}, 
		-[d]	{l^0}, 
		-[dr]	{e^1}), 
)
\end{graph}

\begin{Defin}
	Вспомогательным деревом вывода слова $w$ в грамматике $G$, назовём
	дерево, полученное из классического дерева вывода слова $w$ в грамматике $G$, 
	в результате удаления всех листьев, помеченных $\varepsilon$.
\end{Defin}

\begin{Defin}
	Сокращённым деревом вывода слова $w$ в грамматике $G$, с разметкой $m$ назовём
	дерево, полученное из вспомогательного дерева вывода слова $w$ в грамматике $G$, 
	путём вырезания из дерева всех узлов, размеченных нулями. Ниже дано определение
	вырезания узла из дерева.
\end{Defin}

\begin{Defin}
	Пусть у узла $p_1$ есть сыновья $n_1, n_2, \ldots n_k$. 
	А у узла $n_i, (1 \le i \le k)$ есть сыновья $c_1, c_2, \ldots c_m$.
	Вырезанием узла $n_i$ из дерева, называется операция замены
	в списке сыновей $p_1$ узла $n_i$ на список своих сыновей 
	$c_1, c_2, \ldots c_m$.
\end{Defin}

\begin{Example}
	Сокращённое дерево вывода для классического дерева вывода из предыдущего
	примера.
\end{Example}

Исходное классическое дерево вывода:

\begin{graph}
{T^1}*\frm{o} (
	-[dll]	{R^0}*\frm{o} (
		-[dl]	{s^1}, 
		-[d]	{a^0}, 
		-[dr]	{m^0}), 
	-[d]	{E^0}*\frm{o} (
		-[d]	\varepsilon), 
	-[drr]	{E^1}*\frm{o} (
		-[dl]	{p^1}, 
		-[d]	{l^0}, 
		-[dr]	{e^1}), 
)
\end{graph}

\vspace{12pt}
Вспомогательное дерево вывода:

\begin{graph}
{T^1}*\frm{o} (
	-[dll]	{R^0}*\frm{o} (
		-[dl]	{s^1}, 
		-[d]	{a^0}, 
		-[dr]	{m^0}), 
	-[d]	{E^0}*\frm{o}, 
	-[drr]	{E^1}*\frm{o} (
		-[dl]	{p^1}, 
		-[d]	{l^0}, 
		-[dr]	{e^1}), 
)
\end{graph}

\vspace{12pt}
Сокращённое дерево вывода:

\begin{graph}
{T^1}*\frm{o} (
	-[dl]	{s^1},
	-[dr]	{E^1}*\frm{o} (
		-[dl]	{p^1}, 
		-[dr]	{e^1}), 
)
\end{graph}

\begin{Defin}
	Пусть $CT$ -- это множество всех сокращённых деревьев вывода.
	Определим $ct\langle G, m\rangle$ как синтаксический анализатор, который слову
	ставит в соответствие его сокращённое дерево вывода в грамматике $G$ с разметкой $m$.
\end{Defin}

Далее мы будем изучать свойства данных синтаксических анализаторов, при
применении к грамматике расширяющих преобразований.

\section{Расширяющие пеобразования AE}
\begin{Defin}
	Расширяющим преобразованием размеченных грамматик назовём функцию 
	$f : \Gamma_M \to \Gamma_M$
	такую, что 
	\begin{enumerate}
		\item $L(f(G, m)) \subset L(G)$.
		\item $\forall w \in L(G),  ct\langle  G, m \rangle(w) = ct\langle f(G, m)
		\rangle$
	\end{enumerate}
	Другими словами, расширяющее преобразование увеличивает язык грамматики, но не
	изменяет действия синтаксического анализатора $ct$ на языке исходной грамматики.
\end{Defin}


Определим класс расширяющих преобразований $Add$.
Произвольное правило вывода с произвольной же своей разметкой задаёт преобразование, 
добавляющее это правило в размеченную грамматику. 
Возможно, перед этим понадобится добавить в множество терминалов все ещё отсутствующие 
там терминалы из правой части правила вывода. Множество таких преобразований обозначим $Add$.

Область определения преобразования из $Add$ -- это множество
грамматик, в которых добавляемое правило отсутсвует, а все нетерминалы правила
вывода уже определены в грамматике.

Далее определим класс расширяющих преобразований $Extract$.
Рассмотрим четвёрку $(p, l, r , B)$, где $p$ -- правило вывода 
$A \to \alpha \beta \gamma$, 
$l = |\alpha|$, $r = |\alpha| + |\beta|$, а $B$ --
произвольный символ, не являющийся терминальным в исходной грамматике.
Эта четвёрка определяет преобразование грамматики, удаляющее правило вывода $p$
и добавляющее вместо него два правила вывода: 
$A \to \alpha B \gamma$ и $B \to \beta$. Причём разметка певого на участках $\alpha$ и $\gamma$ совпадает с
разметкой удаляемого правила на тех же участках, разметка символ $B$ в первом добавляемом правиле -- $0$, а
разметка второго добавляемого правила совпадает с разметкой соответствующего участка удаляемого правила
вывода. Множество таких преобразований обозначим $Extract$.

Область определения преобразования из $Extract$ -- это множество грамматик, в
которых присутствует правило вывода $p$ и отсутствует правило вывода $B \to
\beta$, причём терминал $B$ может быть и не определён в исходной грамматике.

\begin{example}
Пример примерения преобразования $Extract$.
\end{example}
Исходную грамматику с одним правилом вывода $p: S \to s^0 a^1 m^0 p^1 l^0 e^1$
преобразование $(p, 2, 4, B)$ превратит в следующую грамматику:
$$S \to s^0 a^1 B^0 l^0 e^1$$
$$B \to m^0 p^1$$

\begin{Defin} Введём два обозначения:
	
	$AE = Add \cup Extract$
	
	$AE^* = \langle AE \rangle$ -- транзитивное замыкание $AE$.
\end{Defin}

\section{Независимые преобразования}

\begin{Defin}
	Пусть $\phi$ и $\psi$ -- это преобразования из AE. Определим операцию $\phi /
	\psi$ следующим образом:
	\begin{enumerate}
	  \item Если $\phi \in Add$ или $\psi \in Add$, то $\phi / \psi = \phi$
	  \item Если 
			$\phi = (p_1, l_1, r_1, N_1)$, 
			$\psi = (p_2, l_2, r_2, N_2)$, 
			а $p_1 \ne p_2$,
			то $\phi / \psi = \phi$.
	  \item  Иначе, введём дополнительные обозначения:
			$\phi = (p, l_1, r_1, N_1)$, $\psi = (p, l_2, r_2, N_2)$, 
			
			$t$, $b$ -- правила вывода, добавляемые преобразованием $\psi$, причём $b$ --
			это то правило вывода, левая часть которого $N_2$. 
			
			$\Delta = l_2 - r_2 + 1$.
			
			Этот случай разбивается на следующие подслучаи:
		\begin{enumerate}
			\item если 
			$l_1 \le l_2 \wedge r_1 > r_2 \vee l_1 < l_2 \wedge r_1 \ge r_2$, то 
			$\phi /	\psi = (t, l_1, r_1 + \Delta, N_1)$
			\item если 
			$r_1 \le l_2$, то 
			$\phi /	\psi = (t, l_1, r_1, N_1)$
			\item если 
			$l_1 \ge l_2$, то 
			$\phi /	\psi = (t, l_1 + \Delta, r_1 + \Delta, N_1)$
			\item если 
			$l_1 \ge l_2 \wedge r_1 < r_2 \vee l_1 > l_2 \wedge r_1 \le r_2$, то 
			$\phi /	\psi = (b, l_1 - l_2, r_1 - l_2, N_1)$
			\item иначе значение не определено.
		\end{enumerate}
    \end{enumerate}
    Для простоты обозначений будем считать, что операция $/$ имеет меньший приоритет, чем
    операция композиции функций. То есть $\phi_2 \phi_1 / \psi_2 \psi_1 = (\phi_2 \phi_1) / (\psi_2 \psi_1)$.
    
    По аналогии с операцией деления будем применять ещё и двухстрочную запись:
    $\phi / \psi = \frac{\phi}{\psi}$.
\end{Defin}


\begin{Defin}
	Доопределим рекурсивно операцию $\phi / \psi$ на преобразования из $AE^*$.
	
	Если $\exists \phi_1 \in AE, \phi_2 \in AE^*: \phi = \phi_2 \phi_1$, то
	\begin{equation}
	\label{E2}
	\frac{\phi}{\psi} = \frac{\phi_2}{\psi / \phi_1} \, \frac{\phi_1}{\psi}
	\end{equation}

	Иначе $\exists \psi_1 \in AE, \psi_2 \in AE^*: \psi = \psi_2 \psi_1$. В этом случае
	\begin{equation}
	\label{E1}
	\frac{\phi}{\psi} = \frac{\phi / \psi_1}{\psi_2}
	\end{equation} 
	
	В обоих тождествах считаем, что если значение хоть одного из подвыражений не
	определено, то значение $\phi / \psi$ также не определено.
\end{Defin}

\begin{Defin}
	Пусть $\phi = \phi_n \phi_{n-1} \ldots \phi_1$, где $\phi_i \in AE$. Тогда $n$
	будем называть сложностью преобразования $\phi$. 
\end{Defin}

\begin{lemma}
	Пусть $\phi \in AE^*$ -- преобразование сложности $n$. 
	Тогда для любого $\psi \in AE^*$, $\phi / \psi$ также имеет сложность $n$. 
\end{lemma}

\begin{Lemma}
	Для любых $\psi_1$, из $AE$ и $\phi$, $\psi_2$ из $AE^*$ верно следующее равенство:
	$$\frac{\phi}{\psi_2 \psi_1} = \frac{\phi / \psi_1}{\psi_2}$$
\end{Lemma}
\begin{proof2}
	Доказательство будет проведено индукцией по сложности преобразования $\phi$.
	База индукции тривиально следует из определения операции $/$.
	
	{\bf Предположение индукции. } 
	Пусть для $\phi$ сложности не более $n$ справедливо равенство:
	\begin{equation}
		\label{PI}
		\frac{\phi}{\psi_2 \psi_1} = \frac{\phi / \psi_1}{\psi_2}
	\end{equation}
	
	{\bf Шаг индукции. }
	$\exists \phi_1 \in AE, \phi_2 \in AE^*: \phi = \phi_2 \phi_1$.
	$$
	\frac{\phi}{\psi_2 \psi_1} =  \frac{\phi_2 \phi_1}{\psi_2 \psi_1} \eq{E2} 
	%Определение /
	\frac{\phi_2}{\psi_2 \psi_1 / \phi_1} \, \frac{\phi_1}{\psi_2 \psi_1} \eq{E2}
	%Определение /
	\frac{\phi_2}{\frac{\psi_2}{\phi_1 / \psi_1} \, \frac{\psi_1}{\phi_1}} \,
		\frac{\phi_1 / \psi_1}{\psi_2} \eq{PI} 
	$$
	%Предположение индукции
	$$
	= \frac{\left(\frac{\phi_2}{\psi_1 / \phi_1}\right)}
			{\left(\frac{\psi_2}{\phi_1 / \psi_1}\right)} \, 
		\left(\frac{\phi_1 / \psi_1}{\psi_2}\right) \eq{E2}
	%Определение /
	\frac{\frac{\phi_2}{\psi_1 / \phi_1} \, \frac{\phi_1}{\psi_1}}{\psi_2} \eq{E2}
	%Определение /
	\frac{\phi_2 \phi_1 / \psi_1}{\psi_2} = \frac{\phi / \psi_1}{\psi_2}
	$$
	
\end{proof2}

\begin{Thm}
	$\frac{\phi}{\psi} \psi = \frac{\psi}{\phi} \phi$
\end{Thm}
\begin{proof2}
	Доказательство будем вести индукцией по сложности преобразований $\phi$ и
	$\psi$.
	
	{ \bf База индукции. }
	Пусть $\phi$ и $\psi$ из $AE$, рассмотрим единственный нетривиальный случай --
	это $\phi = (t, l_1, r_1, N_1), \psi = (t, l_2, r_2, N_2) \in Extract$.
	Существует два принципиально различных случая. Рассмотрим их оба:
	
	1 случай. $l_1 \le l_2 \wedge r_1 > r_2 \vee l_1 < l_2 \wedge r_1 \ge r_2$.
	Преобразование $\psi$ удаляет одно правило вывода 
	$t: A \to \alpha_1 \alpha_2 \beta \gamma_2 \gamma_1$ и вместо него
	добавляет два новых правила:
	$A \to \alpha_1 \alpha_2 N_2 \gamma_2 \gamma_1$,
	$N_2 \to \beta$.
	
	Преобразование $\phi / \psi$ удалит в этой грамматике первое правило вывода и заменит его двумя следующими
	правилами:
	
	$A \to \alpha_1 N_1 \gamma_1$,
	$N_1 \to \alpha_2 N_2 \gamma_2$,
	
	В результате преобразование $(\phi / \psi) \psi$ удалит из исходной грамматики одно правило вывода $t$ и
	добавит три следующих правила вывода:
	
	$A \to \alpha_1 N_1 \gamma_1$,
	$N_1 \to \alpha_2 N_2 \gamma_2$,
	$N_2 \to \beta$.
	
	Аналогичными рассуждениями несложно убедиться, что преобразование $(\psi / \phi) \phi$ делает в точности
	тоже самое.
	
	2 случай. $r_1 \le l_2$. Рассуждениями, аналогичными проделанным в доказательстве предыдущего случая, легко
	показать, что преобразования $(\phi / \psi) \psi$ и $(\psi / \phi) \phi$ совпадают.
	
	
	{\bf Предположение индукции. }
	Пусть для $\phi$ и $\psi$ сложностью не более $n$ справедливо равенство:
	\begin{equation}
		\label{TPI}
		\frac{\phi}{\psi} \psi = \frac{\psi}{\phi} \phi
	\end{equation}
	{\bf Шаг индукции. } Шаг индукции будет доказан в три этапа.
	
	{\bf Этап 1.}  
	Пусть $\psi$ имеет сложность не более $n$, а $\phi = \phi_2 \phi_1$,
	где $\phi_1$ имеет сложность $1$, а $\phi_2$ -- $n$.
		
	$$\frac{\phi} {\psi} \psi = 
	% Определение \phi
	\frac{\phi_2 \phi_1} {\psi} \psi \eq{E2}	
	%E2(phi_2, phi_2, psi)
	\frac{\phi_2}{\psi / \phi_1} \, \frac{\phi_1}{\psi} \psi \eq{TPI}
	% ПИ(psi, phi_1) оба длиной <=n
	\frac{\phi_2} {\psi / \phi_1} \, \frac{\psi}{\phi_1} \phi_1 \eq{TPI} $$ 
	% ПИ(phi_2, psi/phi_1) оба длиной <=n
	$$ = \frac{\psi / \phi_1} {\phi_2} \phi_2 \phi_1 \eq{E1}
	% E1(psi, phi_2, phi_1)
	\frac{\psi} {\phi_2 \phi_1} \phi_2 \phi_1 = 	
	% определение phi
	\frac{\psi / \phi} {\phi}$$ 							
	
	{\bf Этап 2.} Пусть $\phi$ имеет сложность не более $n$, а $\psi = \psi_2 \psi_1$, где 
	$\psi_1$ имеет сложность $1$, а $\psi_2$  -- $n$.
	
	Повторяя рассуждения предыдущего этапа в обратном порядке получаем, 
	$(\psi / \phi)	\phi = (\phi /\psi) \psi$.
	 
	На данный момент мы доказали, что для $\phi$ и $\psi$, один из которых сложности
	$n+1$, а второй не более $n$ утверждение верно. Тем самым, можно
	считать, что мы расширили предположение индукции. Осталось завершить
	доказательство, показав, что в случае, когда оба преобразования имеют
	сложность $n+1$, утверждение также верно.
	
	{\bf Этап 3.} Пусть $\psi$ имеет сложность не более $n+1$, а $\phi = \phi_2 \phi_1$, 
	где $\phi_1$ имеет сложность $1$, а $\phi_2$ -- $n$.
	
	$$\frac{\phi} {\psi} \psi = 
	% определение phi
	\frac{\phi_2 \phi_1}{\psi} \psi \eq{E2}
	% E2(phi_2, phi_1, psi)
	\frac{\phi_2} {\psi / \phi_1} \, \frac{\phi_1}{\psi} \psi = 
	% ПИ(psi, phi_1)
	\frac{\phi_2}{\psi / \phi_1} \, \frac{\psi} {\phi_1} \phi_1 =  
	% ПИ(phi_2, psi/phi_1)
	\frac{\psi / \phi_1} {\phi_2} \phi_2 \phi_1 \eq{E1} 	
	% E1(psi, phi_2, phi_1)
	\frac{\psi}{\phi_2 \phi_1} \phi_2 \phi_1 =  	
	% определение phi
	\frac{\psi}{\phi} \phi$$ 						
\end{proof2}

\begin{Cor}
	Синтаксический анализатор $ct\langle\frac{\phi} {\psi}\psi(G)\rangle$ совместим с синтаксическим анализатором
	$ct\langle \phi(G)\rangle$.
\end{Cor}
\begin{proof2}
	Согласно Теореме 2, $ct\langle(\phi / \psi) \psi(G)\rangle =
	ct\langle(\psi / \phi) \phi(G)\rangle$ совместим с $ct\langle \phi(G)\rangle$,
	так как первое -- это расширение второго.
\end{proof2}


Сейчас можно дать ответы на все вопросы, сформулированные в начале работы.

Во-первых, операция $\frac{\psi}{\phi}$ -- это и есть тот искомый способ модификации преобразования $\psi$
так, чтобы его можно было применять после другого преобразования $\phi$. 

Во-вторых, главное требование к нему -- это совместимость синтаксического анализатора для грамматики
$\frac{\psi}{\phi} \phi(G)$ с синтаксическим анализатором грамматики $\phi(G)$. Это требование выполняется
согласно следствию из теоремы.

В-третьих, как следует из теоремы, порядок применения преобразований значения не имеет.

Полученные результаты можно проиллюстрировать следующей диаграмой:

\xymatrix{
	& G \ar[dl]_\phi \ar[dr]^\psi \\
	G_1 \ar[dr]_{\frac{\psi}{\phi}} & & 
		G_2 \ar[dl]^{\frac{\phi}{\psi}} \\
	& G_3
}

\section{Заключение}

Введённая операция $\phi / \psi$ меняет преобразование $\phi$ так, чтобы его можно было применять после 
преобразования $\psi$. Теорема же показывает, что в случае двух преобразований, не важно какое из них
применять первым -- результат будет одинаковым.

Эти выкладки фактически открывают дорогу к конструированию синтаксических анализаторов довольно сложных языков
из независимых друг от друга простых частей. Каждая такая часть -- это расширяющее преобразование
исходной грамматики.

\end{document}
