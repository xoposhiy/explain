\documentclass[11pt,twoside]{article}
\usepackage[all]{xy}
\usepackage{usu1251}

\righthyphenmin=2\relax %% перенос 2 букв разрешен
\emergencystretch=5pt\relax  %% разрешено разрежение 5pt

% Собственная команда
\newcommand{\restriction}[1]{{\rule[-2mm]{.3pt}{5mm}\rule{1mm}{0mm}}_{#1}}
\newcommand{\eq}[1]{\stackrel{(\ref{#1})}{=}}

\begin{document}

\markboth{{\protect\small\sf 2008 \hfill %Известия УрГУ
%\hfill \No N %TODO Номер
}} 
{\centerline{\protect\small\sf П.\,В.\,Егоров. 
Независимые преобразования грамматик}}
%Краткое название выбирается так, чтобы правый колонтитул уместился в
%одну строку.

% TODO \UDK{УДК Номер УДК!}


\title{О СОВМЕСТИМОСТИ НЕЗАВИСИМЫХ РАСШИРЕНИЙ ГРАМАТИКИ}
\author{П. В. Егоров}
\maketitle

\thispagestyle{firstpage}

\footnotetext{\hfill\\[-.3cm]
\copyright\ П.\,В.\,Егоров, 2008}

\section{Введение}
Последнее время всё больше внимания уделяется вопросу создания расширяемых трансляторов и расширяемых
синтаксических анализаторов в частности. Обычно предполагается, что синтаксический анализатор расширяется
лишь за счёт расширения своей грамматики. Поэтому расширение синтаксического анализатора фактически означает
расширение грамматики.

Под расширяющим преобразованием грамматики обычно [] понимают преобразование, добавляющее в грамматику
некоторый набор новых правил вывода, и, возможно, новые терминальные и нетерминальные символы, использующиеся
в добавляемых правилах. В данной работе используется более общая трактовка расширяющих преобразований --
определён класс $AE$ расширяющих преобразований, в который, в частности, включаются все преобзования
добавляющие в грамматику новые правила.

В данной работе затрагивается вопрос о совместимости нескольких независимых расширений синтаксического
анализатора. Пусть дана грамматика $G$ и два расширяющих преобразования этой грамматики -- $\phi$ и $\psi$.
Каждое преобразование оперирует правилами вывода -- удаляет одни и добавляет другие. 
При этом $\phi(G)$ может быть вне области определения преобразования $\psi$ точно также как и $\psi(G)$ может
быть вне области определения $\phi$. Но даже если последовательное применение обоих преобразований возможно, 
встаёт вопрос о том, зависит ли результат от порядка их применения.

В работе рассматриваются данные вопросы, применительно к размеченным грамматикам и преобразованиям из класса
$AE$. Доказано, что для таких преобразований результат не зависит от порядка их применения. Кроме того,
предложен способ применения к грамматики некоторых наборов несовместимых преобразований, то есть
преобразований, которые невозможно применить к грамматике последовательно.

\section{Размеченная грамматика}
Размеченные грамматики удобны для создания расширяемых синтаксических
анализаторов. В следующем разделе строится синтаксический анализатор, управляемый размеченной грамматикой и
обладающий полезным для расширения свойством: расширенный синтаксический анализатор
на словах исходного языка даёт в точности тот же результат, что и нерасширенный, то есть сохраняет обратную
совместимость.

Пусть дана грамматика $G = (V, \Sigma, P, S)$ и $p$ -- это некоторое
правило вывода из $P$. Введём несколько вспомогательных обозначений.

Через $len(p)$ будем обозначать длину правой части правила вывода $p$.

Через $p(i)$, при $1\leq i \leq len(p)$, будем обозначать $i$-ый символ правой
части правила вывода $p$.

Через $p(0)$ будем обозначать символ левой части правила вывода $p$.

\begin{Defin}
	Разметкой грамматики $G$ будем называть функцию $m$, которая каждому правилу
	вывода грамматики $G$ будет ставить в соответствие кортеж, состоящий из нулей и
	единиц, длиной в количество символов в правой части своего аргумента. Другми
	словами для любого правила $p$ $m(p)$ есть кортеж 
	$$(m_1, m_2, \ldots m_{len(p)}), \quad \mbox{где} \quad m_i \in \{0, 1\}$$ 
\end{Defin}
Кортеж $m(p)$ будем называть разметкой правила $p$.

%Не используется:
%Для удобства введём слудеющее обозначение для элементов кортежа:

%$m(p) = (m(p, 1), m(p, 2), \ldots m(p, len(p)))$.

%Значение $m(p, i)$ будем называть разметкой $i$-ого символа правой части
%правила $p$.


\begin{Defin}
	Определим множество размеченных грамматик $\Gamma_M$ как множество
	всевозможных пар $(G, m)$, где $G \in \Gamma$, а $m \in M$ -- разметка $G$.
	Саму пару $(G, m)$ будем называть размеченной грамматикой.
\end{Defin}


Разметку правила вывода будем обозначать с помощью верхнего индекса у символов
правой части правила вывода. Например для правила вывода 
$p: A \to BCde$  и разметки $m(p) = (0, 1, 0, 1)$, размеченное правило вывода
будем обозначать так:
$p: A \to B^0 C^1 d^0 e^1$

\section{Синтаксический анализатор}

\begin{Defin}
	Пусть $L$ -- некоторый язык. Тогда синтаксическим
	анализатором $L$ будем называть произвольную функцию, определенную на $L$.
\end{Defin}

Ниже будет определён синтаксический анализатор $ct\langle G, m\rangle$,
управляемый размеченной грамматикой. Он будет в качестве результата возвращать
конструкцию, очень похожую на классическое дерево вывода слова в грамматике $G$.
Разметка будет им использоваться для того, чтобы вырезать некоторые
узлы из классического дерева вывода. Рассмотрим всё по порядку. 

Каждому узлу, кроме корня, в классическом дереве вывода можно сопоставить значение 
разметки правила, в результате применения которого появился данный узел. 
Такое сопоставление будем называть разметкой узлов дерева вывода. 
Для единообразия доопределим разметку на корне дерева единицей.
Чтобы пояснить идею разметки дерева вывода, обратимся к примеру:

Пусть дана следующая грамматика:

$$T \to R^0 E^0 E^1$$
$$R \to s^1 a^0 m^0$$
$$E \to \varepsilon$$
$$E \to p^1 l^0 e^1$$

Соответствующее дерево вывода слова <<sample>> в данной грамматике будет
выглядеть так:

\begin{graph}
{T^1}*\frm{o} (
	-[dll]	{R^0}*\frm{o} (
		-[dl]	{s^1}, 
		-[d]	{a^0}, 
		-[dr]	{m^0}), 
	-[d]	{E^0}*\frm{o} (
		-[d]	\varepsilon), 
	-[drr]	{E^1}*\frm{o} (
		-[dl]	{p^1}, 
		-[d]	{l^0}, 
		-[dr]	{e^1}), 
)
\end{graph}

\begin{Defin}
	Вспомогательным деревом вывода слова $w$ в грамматике $G$, назовём
	дерево, полученное из классического дерева вывода слова $w$ в грамматике $G$, 
	в результате удаления всех листьев, помеченных $\varepsilon$.
\end{Defin}

\begin{Defin}
	Сокращённым деревом вывода слова $w$ в грамматике $G$, с разметкой $m$ назовём
	дерево, полученное из вспомогательного дерева вывода слова $w$ в грамматике $G$, 
	путём вырезания из дерева всех узлов, размеченных нулями. Ниже дано определение
	вырезания узла из дерева.
\end{Defin}

\begin{Defin}
	Пусть у узла $p_1$ есть сыновья $n_1, n_2, \ldots n_k$. 
	А у узла $n_i, (1 \le i \le k)$ есть сыновья $c_1, c_2, \ldots c_m$.
	Вырезанием узла $n_i$ из дерева, называется операция замены
	в списке сыновей $p_1$ узла $n_i$ на список своих сыновей 
	$c_1, c_2, \ldots c_m$.
\end{Defin}

\begin{Example}
	Сокращённое дерево вывода для классического дерева вывода из предыдущего
	примера.
\end{Example}

Исходное классическое дерево вывода:

\begin{graph}
{T^1}*\frm{o} (
	-[dll]	{R^0}*\frm{o} (
		-[dl]	{s^1}, 
		-[d]	{a^0}, 
		-[dr]	{m^0}), 
	-[d]	{E^0}*\frm{o} (
		-[d]	\varepsilon), 
	-[drr]	{E^1}*\frm{o} (
		-[dl]	{p^1}, 
		-[d]	{l^0}, 
		-[dr]	{e^1}), 
)
\end{graph}

\vspace{12pt}
Вспомогательное дерево вывода:

\begin{graph}
{T^1}*\frm{o} (
	-[dll]	{R^0}*\frm{o} (
		-[dl]	{s^1}, 
		-[d]	{a^0}, 
		-[dr]	{m^0}), 
	-[d]	{E^0}*\frm{o}, 
	-[drr]	{E^1}*\frm{o} (
		-[dl]	{p^1}, 
		-[d]	{l^0}, 
		-[dr]	{e^1}), 
)
\end{graph}

\vspace{12pt}
Сокращённое дерево вывода:

\begin{graph}
{T^1}*\frm{o} (
	-[dl]	{s^1},
	-[dr]	{E^1}*\frm{o} (
		-[dl]	{p^1}, 
		-[dr]	{e^1}), 
)
\end{graph}

\begin{Defin}
	Определим $ct\langle G, m\rangle$ как синтаксический анализатор, который слову
	ставит в соответствие его сокращённое дерево вывода в грамматике $G$ с разметкой $m$.
\end{Defin}

Далее мы будем изучать свойства данных синтаксических анализаторов, при
применении к грамматике расширяющих преобразований.

\section{Расширяющие пеобразования AE}
\begin{Defin}
	Расширяющим преобразованием размеченных грамматик назовём функцию 
	$f : \Gamma_M \to \Gamma_M$
	такую, что 
	\begin{enumerate}
		\item $L(f(G, m)) \supseteq L(G)$.
		\item $\forall w \in L(G),  ct\langle  G, m \rangle(w) = ct\langle f(G, m)
		\rangle(w)$
	\end{enumerate}
	Другими словами, расширяющее преобразование увеличивает язык грамматики, но не
	изменяет действия синтаксического анализатора $ct$ на языке исходной грамматики.
\end{Defin}


Определим класс расширяющих преобразований $Add$.
Произвольное размеченное правило вывода задаёт преобразование, 
добавляющее это размеченное правило в размеченную грамматику.
Возможно, перед этим понадобится добавить в множество терминалов все ещё отсутствующие 
там терминалы из правой части правила вывода. Если в грамматике уже есть такое правило с точно такой же
разметкой, будем считать, что преобразование не меняет грамматику. Множество таких преобразований обозначим
$Add$.

Область определения преобразования из $Add$ -- это множество
грамматик, в которых добавляемое правило либо отсутсвует, либо присутствует с точно такой же разметкой.

Далее определим класс расширяющих преобразований $Extract$.
Рассмотрим четвёрку $(p, l, r , B)$, где $p$ -- правило вывода 
$A \to \alpha \beta \gamma$, 
$l = |\alpha|$, $r = |\alpha| + |\beta|$ -- номера левой и правой позиции подстроки $\beta$ в правой части
правила, а $B$ -- произвольный символ, не являющийся символом исходной грамматики.
Эта четвёрка определяет преобразование грамматики, удаляющее правило вывода $p$
и добавляющее вместо него два правила вывода:
$A \to \alpha B \gamma$ и $B \to \beta$. Причём разметка певого на участках $\alpha$ и $\gamma$ совпадает с
разметкой удаляемого правила на тех же участках, разметка символа $B$ в первом добавляемом правиле -- $0$, а
разметка второго добавляемого правила совпадает с разметкой соответствующего участка удаляемого правила
вывода. Множество таких преобразований обозначим $Extract$.

Область определения преобразования из $Extract$ -- это множество грамматик, в
которых присутствует правило вывода $p$, а правило вывода $B \to
\beta$ либо отсутствует либо присутствует, но с точно такой же разметкой.

\begin{example}
Пример примерения преобразования $Extract$.
\end{example}
Исходную грамматику с одним правилом вывода $p: S \to s^0 a^1 m^0 p^1 l^0 e^1$
преобразование $(p, 2, 4, B)$ превратит в следующую грамматику:
$$S \to s^0 a^1 B^0 l^0 e^1$$
$$B \to m^0 p^1$$

\begin{Defin} Введём два обозначения:
	
	$AE = Add \cup Extract$
	
	$AE^* = \langle AE \rangle$ -- транзитивное замыкание $AE$.
\end{Defin}

Оказывается синтаксический анализатор $ct$ после расширения его любым
преобразованием из $AE^*$ сохраняет обратную совместимость с соответствующим нерасширенным анализатром.
Более формально это свойство можно сформулировать в виде теоремы.

\begin{Thm}\label{ctThm}
Для любой размеченной грамматики $(G_1, m_1)$ и любого преобразования $\phi \in AE^*$, 
обозначим $(G_2, m_2) = \phi(G_1, m_1)$. Тогда выполняются следующие условия:
\begin{enumerate}
  \item $m_1\restriction{P_1 \cap P_2} = m_2\restriction{P_1 \cap P_2}$;
  \item $ct \langle G_2, m_2 \rangle\restriction{L(G_1)} = ct \langle G_1, m_1
  \rangle$.
\end{enumerate}
\end{Thm}
 

\section{Независимые преобразования}
TODO Префэйз

\begin{Defin}
	Пусть $\phi$ и $\psi$ -- это преобразования из AE. Определим операцию $\phi /
	\psi$ следующим образом:
	\begin{enumerate}
	  \item Если $\phi \in Add$ или $\psi \in Add$, то $\phi / \psi = \phi$
	  \item Если 
			$\phi = (p_1, l_1, r_1, N_1)$,
			$\psi = (p_2, l_2, r_2, N_2)$, 
			а $p_1 \ne p_2$,
			то $\phi / \psi = \phi$.
	  \item  Иначе, введём дополнительные обозначения:
			$\phi = (p, l_1, r_1, N_1)$, $\psi = (p, l_2, r_2, N_2)$, 
			
			$t$, $b$ -- правила вывода, добавляемые преобразованием $\psi$, причём $b$ --
			это то правило вывода, левая часть которого $N_2$. 
			
			$\Delta = l_2 - r_2 + 1$.
			
			Этот случай разбивается на следующие подслучаи:
		\begin{enumerate}
			\item если 
			$l_1 \le l_2 \wedge r_1 > r_2 \vee l_1 < l_2 \wedge r_1 \ge r_2$, то 
			$\phi /	\psi = (t, l_1, r_1 + \Delta, N_1)$
			\item если 
			$r_1 \le l_2$, то 
			$\phi /	\psi = (t, l_1, r_1, N_1)$
			\item если 
			$l_1 \ge r_2$, то 
			$\phi /	\psi = (t, l_1 + \Delta, r_1 + \Delta, N_1)$
			\item если 
			$l_1 \ge l_2 \wedge r_1 < r_2 \vee l_1 > l_2 \wedge r_1 \le r_2$, то 
			$\phi /	\psi = (b, l_1 - l_2, r_1 - l_2, N_1)$
			\item иначе значение не определено.
		\end{enumerate}
    \end{enumerate}
\end{Defin}
Для простоты обозначений будем считать, что операция $/$ имеет меньший приоритет, чем
операция композиции функций. То есть $\phi_2 \phi_1 / \psi_2 \psi_1 = (\phi_2 \phi_1) / (\psi_2 \psi_1)$.

По аналогии с операцией деления будем применять ещё и двухстрочную запись:
$\phi / \psi = \frac{\phi}{\psi}$.


\begin{Defin}
	Доопределим рекурсивно операцию $\phi / \psi$ на преобразования из $AE^*$.
	
	Если существует $\phi_1 \in AE, \phi_2 \in AE^*$ такое, что $\phi = \phi_2 \phi_1$, то
	\begin{equation}
	\label{E2}
	\frac{\phi}{\psi} = \frac{\phi_2}{\psi / \phi_1} \, \frac{\phi_1}{\psi}
	\end{equation}

	Иначе существует $\psi_1 \in AE, \psi_2 \in AE^*$ такое, что $\psi = \psi_2 \psi_1$. В этом случае
	\begin{equation}
	\label{E1}
	\frac{\phi}{\psi} = \frac{\phi / \psi_1}{\psi_2}
	\end{equation} 
	
	В обоих тождествах считаем, что если значение хоть одного из подвыражений не
	определено, то значение $\phi / \psi$ также не определено.
\end{Defin}

\begin{Defin}
	Пусть $\phi = \phi_n \phi_{n-1} \ldots \phi_1$, где $\phi_i \in AE$. Тогда $n$
	будем называть сложностью преобразования $\phi$. 
\end{Defin}
Применение преобразования из $ADD$ увеличивает количество правил в грамматике ровно на 1. 
Значит сложность преобразования -- это количество правил, которое будет добавлено в грамматику после 
применения преобразования.

Непостредственно из определения операции $\cdot / \cdot$ следует следующая лемма.
\begin{Lemma}
	Пусть $\phi \in AE^*$ -- преобразование сложности $n$. 
	Тогда для любого $\psi \in AE^*$, $\phi / \psi$ также имеет сложность $n$. 
\end{Lemma}

\begin{Lemma}
	Для любых $\psi_1$, из $AE$ и $\phi$, $\psi_2$ из $AE^*$ верно следующее равенство:
	$$\frac{\phi}{\psi_2 \psi_1} = \frac{\phi / \psi_1}{\psi_2}$$
\end{Lemma}
\begin{proof2}
	Доказательство будет проведено индукцией по сложности преобразования $\phi$.
	База индукции тривиально следует из определения операции $/$.
	
	{\bf Предположение индукции. } 
	Пусть для $\phi$ сложности не более $n$ справедливо равенство:
	\begin{equation}
		\label{PI}
		\frac{\phi}{\psi_2 \psi_1} = \frac{\phi / \psi_1}{\psi_2}
	\end{equation}
	
	{\bf Шаг индукции. }
	$\exists \phi_1 \in AE, \phi_2 \in AE^*: \phi = \phi_2 \phi_1$.
	$$
	\frac{\phi}{\psi_2 \psi_1} =  \frac{\phi_2 \phi_1}{\psi_2 \psi_1} \eq{E2} 
	%Определение /
	\frac{\phi_2}{\psi_2 \psi_1 / \phi_1} \, \frac{\phi_1}{\psi_2 \psi_1} \eq{E2}
	%Определение /
	\frac{\phi_2}{\frac{\psi_2}{\phi_1 / \psi_1} \, \frac{\psi_1}{\phi_1}} \,
		\frac{\phi_1 / \psi_1}{\psi_2} \eq{PI} 
	$$
	%Предположение индукции
	$$
	= \frac{\left(\frac{\phi_2}{\psi_1 / \phi_1}\right)}
			{\left(\frac{\psi_2}{\phi_1 / \psi_1}\right)} \, 
		\left(\frac{\phi_1 / \psi_1}{\psi_2}\right) \eq{E2}
	%Определение /
	\frac{\frac{\phi_2}{\psi_1 / \phi_1} \, \frac{\phi_1}{\psi_1}}{\psi_2} \eq{E2}
	%Определение /
	\frac{\phi_2 \phi_1 / \psi_1}{\psi_2} = \frac{\phi / \psi_1}{\psi_2}
	$$
	
\end{proof2}

\begin{Thm}
	$\frac{\phi}{\psi} \psi = \frac{\psi}{\phi} \phi$
\end{Thm}
\begin{proof2}
	Доказательство будем вести индукцией по сложности преобразований $\phi$ и
	$\psi$.
	
	{ \bf База индукции. }
	Пусть $\phi$ и $\psi$ из $AE$, рассмотрим единственный нетривиальный случай --
	это $\phi = (t, l_1, r_1, N_1), \psi = (t, l_2, r_2, N_2) \in Extract$.
	Существует два принципиально различных случая. Рассмотрим их оба:
	
	1 случай. $l_1 \le l_2 \wedge r_1 > r_2 \vee l_1 < l_2 \wedge r_1 \ge r_2$.
	Преобразование $\psi$ удаляет одно правило вывода 
	$t: A \to \alpha_1 \alpha_2 \beta \gamma_2 \gamma_1$ и вместо него
	добавляет два новых правила:
	$A \to \alpha_1 \alpha_2 N_2 \gamma_2 \gamma_1$,
	$N_2 \to \beta$.
	
	Преобразование $\phi / \psi$ удалит в этой грамматике первое правило вывода и заменит его двумя следующими
	правилами:
	
	$A \to \alpha_1 N_1 \gamma_1$,
	$N_1 \to \alpha_2 N_2 \gamma_2$,
	
	В результате преобразование $(\phi / \psi) \psi$ удалит из исходной грамматики одно правило вывода $t$ и
	добавит три следующих правила вывода:
	
	$A \to \alpha_1 N_1 \gamma_1$,
	$N_1 \to \alpha_2 N_2 \gamma_2$,
	$N_2 \to \beta$.
	
	Аналогичными рассуждениями несложно убедиться, что преобразование $(\psi / \phi) \phi$ делает в точности
	тоже самое.
	
	2 случай. $r_1 \le l_2$. Рассуждениями, аналогичными проделанным в доказательстве предыдущего случая, легко
	показать, что преобразования $(\phi / \psi) \psi$ и $(\psi / \phi) \phi$ совпадают.
	
	
	{\bf Предположение индукции. }
	Пусть для $\phi$ и $\psi$ сложностью не более $n$ справедливо равенство:
	\begin{equation}
		\label{TPI}
		\frac{\phi}{\psi} \psi = \frac{\psi}{\phi} \phi
	\end{equation}
	{\bf Шаг индукции. } Шаг индукции будет доказан в три этапа.
	
	{\bf Этап 1.}  
	Пусть $\psi$ имеет сложность не более $n$, а $\phi = \phi_2 \phi_1$,
	где $\phi_1$ имеет сложность $1$, а $\phi_2$ -- $n$.
		
	$$\frac{\phi} {\psi} \psi = 
	% Определение \phi
	\frac{\phi_2 \phi_1} {\psi} \psi \eq{E2}	
	%E2(phi_2, phi_2, psi)
	\frac{\phi_2}{\psi / \phi_1} \, \frac{\phi_1}{\psi} \psi \eq{TPI}
	% ПИ(psi, phi_1) оба длиной <=n
	\frac{\phi_2} {\psi / \phi_1} \, \frac{\psi}{\phi_1} \phi_1 \eq{TPI} $$ 
	% ПИ(phi_2, psi/phi_1) оба длиной <=n
	$$ = \frac{\psi / \phi_1} {\phi_2} \phi_2 \phi_1 \eq{E1}
	% E1(psi, phi_2, phi_1)
	\frac{\psi} {\phi_2 \phi_1} \phi_2 \phi_1 = 	
	% определение phi
	\frac{\psi}{\phi} \phi$$ 							
	
	{\bf Этап 2.} Пусть $\phi$ имеет сложность не более $n$, а $\psi = \psi_2 \psi_1$, где 
	$\psi_1$ имеет сложность $1$, а $\psi_2$  -- $n$.
	
	Повторяя рассуждения предыдущего этапа в обратном порядке получаем, 
	$(\psi / \phi)	\phi = (\phi /\psi) \psi$.
	 
	На данный момент мы доказали, что для $\phi$ и $\psi$, один из которых сложности
	$n+1$, а второй не более $n$ утверждение верно. Тем самым, можно
	считать, что мы расширили предположение индукции. Осталось завершить
	доказательство, показав, что в случае, когда оба преобразования имеют
	сложность $n+1$, утверждение также верно.
	
	{\bf Этап 3.} Пусть $\psi$ имеет сложность не более $n+1$, а $\phi = \phi_2 \phi_1$, 
	где $\phi_1$ имеет сложность $1$, а $\phi_2$ -- $n$.
	
	$$\frac{\phi} {\psi} \psi = 
	% определение phi
	\frac{\phi_2 \phi_1}{\psi} \psi \eq{E2}
	% E2(phi_2, phi_1, psi)
	\frac{\phi_2} {\psi / \phi_1} \, \frac{\phi_1}{\psi} \psi = 
	% ПИ(psi, phi_1)
	\frac{\phi_2}{\psi / \phi_1} \, \frac{\psi} {\phi_1} \phi_1 =  
	% ПИ(phi_2, psi/phi_1)
	\frac{\psi / \phi_1} {\phi_2} \phi_2 \phi_1 \eq{E1} 	
	% E1(psi, phi_2, phi_1)
	\frac{\psi}{\phi_2 \phi_1} \phi_2 \phi_1 =  	
	% определение phi
	\frac{\psi}{\phi} \phi$$ 						
\end{proof2}

\begin{Cor}
	Синтаксический анализатор $ct\langle\frac{\phi} {\psi}\psi(G)\rangle$ совместим с синтаксическим анализатором
	$ct\langle \phi(G)\rangle$.
\end{Cor}
\begin{proof2}
	Согласно теореме \ref{ctThm}, $ct\langle(\phi / \psi) \psi(G)\rangle =
	ct\langle(\psi / \phi) \phi(G)\rangle$ совместим с $ct\langle \phi(G)\rangle$,
	так как первое -- это расширение второго.
\end{proof2}


TODO переформулировать согласно текущим формулировкам начала работы.

Сейчас можно дать ответы на все вопросы, сформулированные в начале работы.

Во-первых, операция $\frac{\psi}{\phi}$ -- это и есть тот искомый способ модификации преобразования $\psi$
так, чтобы его можно было применять после другого преобразования $\phi$. 

Во-вторых, главное требование к нему -- это совместимость синтаксического анализатора для грамматики
$\frac{\psi}{\phi} \phi(G)$ с синтаксическим анализатором грамматики $\phi(G)$. Это требование выполняется
согласно следствию из теоремы.

В-третьих, как следует из теоремы, порядок применения преобразований значения не имеет.

Полученные результаты можно проиллюстрировать следующей диаграмой:

\xymatrix{
	& G \ar[dl]_\phi \ar[dr]^\psi \\
	G_1 \ar[dr]_{\frac{\psi}{\phi}} & & 
		G_2 \ar[dl]^{\frac{\phi}{\psi}} \\
	& G_3
}

\section{Заключение}

Введённая операция $\phi / \psi$ меняет преобразование $\phi$ так, чтобы его можно было применять после 
преобразования $\psi$. Теорема же показывает, что в случае двух преобразований, не важно какое из них
применять первым -- результат будет одинаковым.

Эти выкладки фактически открывают дорогу к конструированию синтаксических анализаторов довольно сложных языков
из независимых друг от друга простых частей. Каждая такая часть -- это расширяющее преобразование
исходной грамматики.

\end{document}
